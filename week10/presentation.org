#+TITLE: CMPUT201W20B2 Week 10
#+PROPERTY: header-args:C             :results output :exports no-export :flags -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 :eval yes :results value verbatim
#+PROPERTY: header-args:sh            :results output :exports no-export :eval yes :results value verbatim
#+PROPERTY: header-args:shell         :results output :exports no-export :eval yes :results value verbatim

* Week10
** Copyright Statement

If you are in CMPUT201 at UAlberta this code is released in the public
domain to you.

Otherwise it is (c) 2020 Abram Hindle, Hazel Campbell AGPL3.0+

*** License

    CMPUT 201 C Notes
    Copyright (C) 2020 Abram Hindle, Hazel Campbell

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.


*** Hazel Code is licensed under AGPL3.0+

Hazel's code is also found here
https://github.com/hazelybell/examples/tree/C-2020-01

Hazel code is licensed: The example code is licensed under the AGPL3+
license, unless otherwise noted.

** Init ORG-MODE

#+BEGIN_SRC elisp
;; I need this for org-mode to work well
;; If we have a new org-mode use ob-shell
;; otherwise use ob-sh --- but not both!
(if (require 'ob-shell nil 'noerror)
  (progn
    (org-babel-do-load-languages 'org-babel-load-languages '((shell . t))))
  (progn
    (require 'ob-sh)
    (org-babel-do-load-languages 'org-babel-load-languages '((sh . t)))))
(org-babel-do-load-languages 'org-babel-load-languages '((C . t)))
(org-babel-do-load-languages 'org-babel-load-languages '((python . t)))
(setq org-src-fontify-natively t)
(setq org-confirm-babel-evaluate nil) ;; danger!
(custom-set-faces
 '(org-block ((t (:inherit shadow :foreground "black"))))
 '(org-code ((t (:inherit shadow :foreground "black")))))
#+END_SRC

#+RESULTS:

*** Org export
#+BEGIN_SRC elisp
(org-html-export-to-html)
(org-latex-export-to-pdf)
(org-ascii-export-to-ascii)
#+END_SRC

#+RESULTS:
: presentation.txt


*** Org Template
Copy and paste this to demo C

#+BEGIN_SRC C :exports both
#include <stdio.h>

int main(int argc, char**argv) {
    return 0;
}
#+END_SRC

#+RESULTS:

** Remember how to compile?

gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o programname programname.c

** Preprocessor stuff like if-def
   The preprocessor deals with all the lines that you start with an
   octalthrope or hash mark: #
  
   The preprocessor lets you define symbols, macros, and include
   files.

*** Multiple Files?

How does stdio.h work?

file:/usr/include/stdio.h

It defines definitions, macros, and prototypes for the stdio library.
The linker will link your executable to that library that was already
compiled.

.h files help us organize C programs by including definitions for the
object files and libraries that we will create.

Libc or glibc contains the implemention of those definitions.
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f919f994000)

libc is composed of many .c files compiled into .o object files and
then combined into a library. A library is like an executable that
other executables rely on for code. malloc is defined in malloc.c and
has a malloc.h file!

Typically if I make a library I will make a .h file so the definitions
can be shared with other .c files. But the implementation of the functions
will go into a .c file that includes that .h as well.

- main.c
  - #include "library.h"
  - relies on library.o 
- library.c
  - #include "library.h"
  - makes library.o
- library.h
  - defines functions and definitions from library.c

*** Example 

This is a useful function to check if scanf read 1 or more elements
and didn't read EOF.

file:./checkinput.c

#+BEGIN_SRC C :exports both :tangle checkinput.c :main no
#include "checkinput.h"
#include <stdio.h>
#include <stdlib.h>
/* checkInput: given the result of scanf check if it 
 * 0 elements read or EOF. If so exit(1) with a warning.
 *
 */
void checkInput(int err) {
  if (!err || err == EOF) {
    printf("\nInvalid input!\n");
    exit(1);
  }
}
#+END_SRC 

#+RESULTS:

file:./checkinput.h

#+BEGIN_SRC C :exports both :tangle checkinput.h :main no
// Have a guard to ensure that we don't include it multiple times.
#ifndef _CHECKINPUT_H_
/* checkInput: given the result of scanf check if it 
 * 0 elements read or EOF. If so exit(1) with a warning.
 *
 */
#define _CHECKINPUT_H_
void checkInput(int err); // a prototype!
#endif
#+END_SRC 

#+RESULTS:

file:./checkinput-driver.c

#+BEGIN_SRC C :exports both :tangle checkinput-driver.c
#include "checkinput.h"
#include <stdio.h>
#include "checkinput.h"

int main() {
  int input;
  checkInput(scanf("%d", &input));  
  puts("Good Input!");
}
#+END_SRC 

#+RESULTS:

**** Compiling Multiple Files Easy Mode

We can put all our .c files on the same line and compile them all at
once! This is handy. But quite limiting.

We can't parallel compile. We can't use all our cores. We can't
interupt compilation.

#+BEGIN_SRC sh :exports both :tangle build-checkinput-easy.sh
# build checkinput-driver
gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 \
       -o checkinput-driver checkinput-driver.c \
       checkinput.c && \
( echo YES | ./checkinput-driver  || \
  echo 100 | ./checkinput-driver )
#+END_SRC

#+RESULTS:
: 
: Invalid input!
: Good Input!


**** Compiling Multiple Files with Linking

OK now we compile it. The main is the last to compile and it needs all
the .o files.

All the .c files that don't contain main need to be compiled to object
files. Use the -c flags to do this.

#+BEGIN_SRC sh :exports both :tangle build-checkinput.sh
# build checkinput.o
gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 \
       -c checkinput.c
file checkinput.o
# build checkinput-driver and link it to checkinput.o
gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 \
       -o checkinput-driver checkinput-driver.c \
       checkinput.o
file checkinput-driver
#+END_SRC

#+RESULTS:
: checkinput.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), with debug_info, not stripped
: checkinput-driver: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=2df2006fd89c9d9dbc9655f59e4cf90c6d3f6017, with debug_info, not stripped

- If you want some translation :-)
  - ELF - Executable and Linking format
  - relocatable - you can link it
  - shared object - relocatable and executable
  - LSB - little endian/least significant bit
  - x86-64 - 64 bit x86 processor
  - version 1 (SYSV) - version 1 of ELF System V Unix spec.

Test drive it

#+BEGIN_SRC sh :exports both
echo    | ./checkinput-driver # bad
echo X  | ./checkinput-driver # bad
echo 1  | ./checkinput-driver # good
echo -1 | ./checkinput-driver # good
#+END_SRC

#+RESULTS:
: 
: Invalid input!
: 
: Invalid input!
: Good Input!
: Good Input!

Now let's see how it is linked!

#+BEGIN_SRC sh
ldd ./checkinput-driver
#+END_SRC

#+RESULTS:
: 	linux-vdso.so.1 (0x00007ffe85be0000)
: 	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f919f994000)
: 	/lib64/ld-linux-x86-64.so.2 (0x00007f919ff87000)

- syscalls (read, write, gettimeofday) and libc (libc is stuff like stdio.h)

*** Linking to libraries

`math.h` includes fun functions like cos and tanh.

Math.h, part of the C stdlib, is distributed as a seperate library.
Not all computers have floating point numbers so why bother compiling
floating code for them?

file:/usr/include/math.h

#+BEGIN_SRC sh :exports none
gnome-terminal --window-with-profile Big \
               -- man math.h
#+END_SRC

#+RESULTS:

I add the flag -lm so we get our math library :-)
#+begin_src C :libs -lm :tangle poor-tanh-example.c 
#include <stdio.h>
#include <math.h>

int main() {
    double x = 0.0;
    double th = tanh(x);
    double lh = th;
    do {
        lh = th;
        x += 0.5;
        th = tanh(x);
        printf("tanh(%e) == %e\n", x, th);
    } while( lh != th );
}
#+end_src

#+RESULTS:
#+begin_example
tanh(5.000000e-01) == 4.621172e-01
tanh(1.000000e+00) == 7.615942e-01
tanh(1.500000e+00) == 9.051483e-01
tanh(2.000000e+00) == 9.640276e-01
tanh(2.500000e+00) == 9.866143e-01
tanh(3.000000e+00) == 9.950548e-01
tanh(3.500000e+00) == 9.981779e-01
tanh(4.000000e+00) == 9.993293e-01
tanh(4.500000e+00) == 9.997532e-01
tanh(5.000000e+00) == 9.999092e-01
tanh(5.500000e+00) == 9.999666e-01
tanh(6.000000e+00) == 9.999877e-01
tanh(6.500000e+00) == 9.999955e-01
tanh(7.000000e+00) == 9.999983e-01
tanh(7.500000e+00) == 9.999994e-01
tanh(8.000000e+00) == 9.999998e-01
tanh(8.500000e+00) == 9.999999e-01
tanh(9.000000e+00) == 1.000000e+00
tanh(9.500000e+00) == 1.000000e+00
tanh(1.000000e+01) == 1.000000e+00
tanh(1.050000e+01) == 1.000000e+00
tanh(1.100000e+01) == 1.000000e+00
tanh(1.150000e+01) == 1.000000e+00
tanh(1.200000e+01) == 1.000000e+00
tanh(1.250000e+01) == 1.000000e+00
tanh(1.300000e+01) == 1.000000e+00
tanh(1.350000e+01) == 1.000000e+00
tanh(1.400000e+01) == 1.000000e+00
tanh(1.450000e+01) == 1.000000e+00
tanh(1.500000e+01) == 1.000000e+00
tanh(1.550000e+01) == 1.000000e+00
tanh(1.600000e+01) == 1.000000e+00
tanh(1.650000e+01) == 1.000000e+00
tanh(1.700000e+01) == 1.000000e+00
tanh(1.750000e+01) == 1.000000e+00
tanh(1.800000e+01) == 1.000000e+00
tanh(1.850000e+01) == 1.000000e+00
tanh(1.900000e+01) == 1.000000e+00
tanh(1.950000e+01) == 1.000000e+00
tanh(2.000000e+01) == 1.000000e+00
#+end_example

OK so how does this work, how do link to math?

#+BEGIN_SRC sh :exports both :tangle build-tanh-example.sh
# build checkinput-driver and link it to checkinput.o
gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 \
       -o poor-tanh-example poor-tanh-example.c \
       -lm
file poor-tanh-example
./poor-tanh-example | wc
ldd ./poor-tanh-example
#+END_SRC

#+RESULTS:
: poor-tanh-example: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=fdd28691d4637c2a9b9a76b129ea7585894e4378, with debug_info, not stripped
:      40     120    1400
: 	linux-vdso.so.1 (0x00007ffdd1570000)
: 	libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f4ed467b000)
: 	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4ed428a000)
: 	/lib64/ld-linux-x86-64.so.2 (0x00007f4ed4c1b000)

See that? libm.so.6 is in there.

Larger programs link to lots of libraries.

#+BEGIN_SRC sh :exports both
ldd `which xterm`
#+END_SRC

#+RESULTS:
#+begin_example
	linux-vdso.so.1 (0x00007ffdabcea000)
	libXft.so.2 => /usr/lib/x86_64-linux-gnu/libXft.so.2 (0x00007fc90b414000)
	libfontconfig.so.1 => /usr/lib/x86_64-linux-gnu/libfontconfig.so.1 (0x00007fc90b1cf000)
	libXaw.so.7 => /usr/lib/x86_64-linux-gnu/libXaw.so.7 (0x00007fc90af5b000)
	libXmu.so.6 => /usr/lib/x86_64-linux-gnu/libXmu.so.6 (0x00007fc90ad42000)
	libXt.so.6 => /usr/lib/x86_64-linux-gnu/libXt.so.6 (0x00007fc90aad9000)
	libX11.so.6 => /usr/lib/x86_64-linux-gnu/libX11.so.6 (0x00007fc90a7a1000)
	libXinerama.so.1 => /usr/lib/x86_64-linux-gnu/libXinerama.so.1 (0x00007fc90a59e000)
	libXpm.so.4 => /usr/lib/x86_64-linux-gnu/libXpm.so.4 (0x00007fc90a38c000)
	libICE.so.6 => /usr/lib/x86_64-linux-gnu/libICE.so.6 (0x00007fc90a171000)
	libutempter.so.0 => /usr/lib/x86_64-linux-gnu/libutempter.so.0 (0x00007fc909f6e000)
	libtinfo.so.5 => /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007fc909d44000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc909953000)
	libfreetype.so.6 => /usr/lib/x86_64-linux-gnu/libfreetype.so.6 (0x00007fc90969f000)
	libXrender.so.1 => /usr/lib/x86_64-linux-gnu/libXrender.so.1 (0x00007fc909495000)
	libexpat.so.1 => /lib/x86_64-linux-gnu/libexpat.so.1 (0x00007fc909263000)
	libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fc909044000)
	libXext.so.6 => /usr/lib/x86_64-linux-gnu/libXext.so.6 (0x00007fc908e32000)
	libSM.so.6 => /usr/lib/x86_64-linux-gnu/libSM.so.6 (0x00007fc908c2a000)
	libxcb.so.1 => /usr/lib/x86_64-linux-gnu/libxcb.so.1 (0x00007fc908a02000)
	libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fc9087fe000)
	libbsd.so.0 => /lib/x86_64-linux-gnu/libbsd.so.0 (0x00007fc9085e9000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fc90b8d9000)
	libpng16.so.16 => /usr/lib/x86_64-linux-gnu/libpng16.so.16 (0x00007fc9083b7000)
	libz.so.1 => /lib/x86_64-linux-gnu/libz.so.1 (0x00007fc90819a000)
	libuuid.so.1 => /lib/x86_64-linux-gnu/libuuid.so.1 (0x00007fc907f93000)
	libXau.so.6 => /usr/lib/x86_64-linux-gnu/libXau.so.6 (0x00007fc907d8f000)
	libXdmcp.so.6 => /usr/lib/x86_64-linux-gnu/libXdmcp.so.6 (0x00007fc907b89000)
	librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007fc907981000)
	libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007fc9075e3000)
#+end_example

See! Lots of libraries!

**** Summary 

To link to a shared library with gcc or clang use the:
  -l flag
  -llibraryyouwant

For libm use -lm for librt use -lrt

If your library is not in the current lib path you will need to
specify a library path use -L/path/to/library

OK let's see how it affects you.

*** Example Datastructure

Let's make a brief data structure about one of my favourite topics:
cool bears.

file:./coolbears.c

#+BEGIN_SRC C :exports both :tangle coolbears.c :main no
#define _POSIX_C_SOURCE 200809L // <-- needed for strdup
#include "coolbears.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// hiding struct details from other programmers
// I DONT TRUST THEM. Especially Hazel ;-) (don't tell hazel)
struct coolbear_t {
    char * name;
    float temperature;
};

CoolBear createCoolBear(char * name, float temperature) {
    CoolBear coolbear = malloc(sizeof(*coolbear));
    coolbear->name = strdup(name);
    coolbear->temperature = temperature;
    return coolbear;
}
void freeCoolBear(CoolBear coolBear) {
    if (coolBear == NULL) {
        abort();
    }
    if (coolBear->name != NULL) {
        free(coolBear->name);
    }
    free(coolBear);
}
char * getNameCoolBear(CoolBear coolbear) {
    return coolbear->name;
}
float    getTemperatureCoolBear(CoolBear coolbear) {
   return coolbear->temperature;
}
// NO MAIN!
#+END_SRC 



#+RESULTS:

file:./coolbears.h

#+BEGIN_SRC C :exports both :tangle coolbears.h :main no
// Have a guard to ensure that we don't include it multiple times.
#ifndef _COOLBEARS_H_
/* checkInput: given the result of scanf check if it 
 * 0 elements read or EOF. If so exit(1) with a warning.
 *
 */
#define _COOLBEARS_H_
struct coolbear_t; // Forward declaration -- I am not sharing details!
typedef struct coolbear_t * CoolBear; // Struct point as type

CoolBear createCoolBear(char * name, float temperature); // a prototype!
void     freeCoolBear(CoolBear coolBear); // a prototype!
char *   getNameCoolBear(CoolBear coolbear); // a prototype!
float    getTemperatureCoolBear(CoolBear coolbear); // a prototype!

#endif
#+END_SRC 

#+RESULTS:

file:./coolbears-driver.c

#+BEGIN_SRC C :exports both :tangle coolbears-driver.c :libs coolbears.c
#include "coolbears.h"
#include <stdio.h>

int main() {
  CoolBear ziggy = createCoolBear("Ziggy",-23.0 /* C */);
  CoolBear kevin = createCoolBear("Kevin",-32.0 /* C */);
  CoolBear coolest = (getTemperatureCoolBear(ziggy) < 
                      getTemperatureCoolBear(kevin))? ziggy : kevin;
  printf("The coolest bear is %s\n", getNameCoolBear( coolest ));
  // // we actually don't know about name so we can't reference it below
  // printf("The coolest bear is %s\n", getNameCoolBear( coolest->name ));
  freeCoolBear(ziggy);
  freeCoolBear(kevin);
}
#+END_SRC 

#+RESULTS:

Compile it. -c the coolbears.c to make coolbears.o and then 
compile coolbears-driver.c

coolbears-driver.c has no clue how to access 

#+BEGIN_SRC sh :exports both :tangle build-coolbears.sh
# build coolbears.o
gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 \
       -c coolbears.c
# build coolbears-driver and link it to coolbears.o
gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 \
       -o coolbears-driver coolbears-driver.c \
       coolbears.o 
./coolbears-driver
#+END_SRC

#+RESULTS:
: The coolest bear is Kevin

If we access coolest->name we get:

#+begin_example
coolbears-driver.c: In function ‘main’:
coolbears-driver.c:11:62: error: dereferencing pointer to incomplete type ‘struct coolbear_t’
   printf("The coolest bear is %s\n", getNameCoolBear( coolest->name ));
#+end_example


*** What is the preprocessor doing?

Let's use the -E flag to see what checkinput.c becomes

This output contains glibc headers for stdio.h and stdlib.h these
should be under the GPLV3 (c) the Glibc project and GNU project.

If you want more preprocessor options checkout:

https://gcc.gnu.org/onlinedocs/gcc-5.2.0/gcc/Preprocessor-Options.html

#+BEGIN_SRC sh :eval yes :exports both :results value drawer code
# build checkinput.o
gcc -E -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 \
       checkinput.c > checkinput-preprocessor.c
#+END_SRC

#+RESULTS:
#+begin_src sh
#+end_src


#+begin_src C :eval no
# 1 "checkinput.c"
# 1 "/home/hindle1/projects/CMPUT201W20/2020-01/CMPUT201W20B2-public/week10//"
# 1 "<built-in>"
#define __STDC__ 1
#define __STDC_VERSION__ 199901L
#define __STDC_HOSTED__ 1
#define __GNUC__ 7
#define __GNUC_MINOR__ 5
#define __GNUC_PATCHLEVEL__ 0

// lots of definitions

# 1 "/usr/include/stdio.h" 1 3 4
# 24 "/usr/include/stdio.h" 3 4
#define _STDIO_H 1

// Start of STDIO_H

// ...

extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));


// LOTS OF STDIO.H


// LOTS OF STDLIB.H

# 1016 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1017 "/usr/include/stdlib.h" 2 3 4
# 1026 "/usr/include/stdlib.h" 3 4

# 5 "checkinput.c" 2





# 9 "checkinput.c"
void checkInput(int err) {
  if (!err || err == 
# 10 "checkinput.c" 3 4
                    (-1)
# 10 "checkinput.c"
                       ) {
    printf("\nInvalid input!\n");
    exit(1);
  }
}
return 0;
}
#+end_C

file:checkinput-preprocessor.c





