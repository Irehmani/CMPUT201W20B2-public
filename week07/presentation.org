#+TITLE: CMPUT201W20B2 Week 7
#+PROPERTY: header-args:C             :results output :exports both :flags -std=c99 -Wall -pedantic -Werror -g :eval yes :results value drawer
#+PROPERTY: header-args:sh            :results output :exports both

* Week7
** Copyright Statement

If you are in CMPUT201 at UAlberta this code is released in the public
domain to you.

Otherwise it is (c) 2020 Abram Hindle, Hazel Campbell AGPL3.0+

*** License

    Week 3 notes
    Copyright (C) 2020 Abram Hindle, Hazel Campbell

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.


*** Hazel Code is licensed under AGPL3.0+

Hazel's code is also found here
https://github.com/hazelybell/examples/tree/C-2020-01

Hazel code is licensed: The example code is licensed under the AGPL3+
license, unless otherwise noted.

** Init ORG-MODE

#+BEGIN_SRC elisp
;; I need this for org-mode to work well

(require 'ob-sh)
;(require 'ob-shell)
(org-babel-do-load-languages 'org-babel-load-languages '((sh . t)))
(org-babel-do-load-languages 'org-babel-load-languages '((C . t)))
(org-babel-do-load-languages 'org-babel-load-languages '((python . t)))
(setq org-src-fontify-natively t)
#+END_SRC

#+RESULTS:
: t

** Org Template
Copy and paste this to demo C

#+BEGIN_SRC C :exports both
#include <stdio.h>

int main(int argc, char**argv) {
    return 0;
}
#+END_SRC

#+RESULTS:

** Remember how to compile?

gcc -std=c99 -Wall -pedantic -Werror -o programname programname.c


** Enums!

Enums are enumerations, which is just a convienant way to make symbols
that have different values of the same type. Enums allow us to read
and write values from files and inputs and extract their symbolic meaning.

Enums are fundamental to symbolic computation.

Enum work good for switch cases, if statements, for loops.

Enums are good for representing the type of something or a category.

*** Enum Example

Enums are good for representing states, symbols, simple values, etc.

#+BEGIN_SRC C :exports both
#include <stdio.h>
#include <stdlib.h>

#define N_DIRECTIONS 4
enum direction {
    UP=1, DOWN=2, LEFT=3, RIGHT=0
};
typedef enum direction Direction;

const char * const direction_names[N_DIRECTIONS] = {
    [UP] = "Up",
    [DOWN] = "Down",
    [LEFT] = "Left",
    [RIGHT] = "Right"
};

Direction clockwise(Direction direction) {
    switch (direction) {
        case UP:
            return RIGHT;
        case RIGHT:
            return DOWN;
        case DOWN:
            return LEFT;
        case LEFT:
            return UP;
        default:
            abort();
    }
}

int main() {
    Direction d = UP;
    for (int i = 0 ; i < 10; i++) {
        d = clockwise(d);
        printf("%d %s\t[%d]\n", i, direction_names[d], d);
    }
}
#+END_SRC

#+RESULTS:
:RESULTS:
0 Right	[0]
1 Down	[2]
2 Left	[3]
3 Up	[1]
4 Right	[0]
5 Down	[2]
6 Left	[3]
7 Up	[1]
8 Right	[0]
9 Down	[2]
:END:

*** enum_typedef.c

Enums are annoying to type. Typing enum enumname all the time is
repetitive. Typedefs allow us to label enum types with 1 word.

Typedef this 

enum enumname { ... } ;

with:

typedef enum enunumae Enumename ;


#+BEGIN_SRC C :exports both
#include <stdio.h>
#include <stdlib.h>

enum flavor {
    VANILLA,
    CHOCOLATE,
    STRAWBERRY,
};

typedef enum flavor Flavor;

int main() {
    Flavor favourite = VANILLA;
    printf("favourite=%d\n", favourite);
    printf("sizeof(favourite)=%zu\n",
           sizeof(favourite));
    
    switch (favourite) {
        case VANILLA:
            printf("favourite=VANILLA\n");
            break;
        case CHOCOLATE:
            printf("favourite=CHOCOLATE\n");
            break;
        case STRAWBERRY:
            printf("favourite=STRAWBERRY\n");
            break;
        default:
            abort();
    }
}
#+END_SRC

#+RESULTS:
: favourite=0
: sizeof(favourite)=4
: favourite=VANILLA



*** EnumStart

#+BEGIN_SRC C :exports both
#include <stdio.h>
#include <stdlib.h>

enum flavor {
    VANILLA = 100,
    CHOCOLATE,
    STRAWBERRY,
};

typedef enum flavor Flavor;

const char * flavorString(Flavor flavor) {
    switch (flavor) {
        case VANILLA:
            return "Vanilla";
        case CHOCOLATE:
            return "Chocolate";
        default:
            abort();
    }
}


int main() {
    printf("VANILLA=%d\n", VANILLA);
    printf("CHOCOLATE=%d\n", CHOCOLATE);
    printf("STRAWBERRY=%d\n", STRAWBERRY);
    printf("sizeof(Flavor)=%zu\n",
           sizeof(Flavor));
    puts(flavorString(VANILLA));
    puts(flavorString(100));

}
#+END_SRC

#+RESULTS:
:RESULTS:
VANILLA=100
CHOCOLATE=101
STRAWBERRY=102
sizeof(Flavor)=4
Vanilla
Vanilla
:END:

*** Enumassign 

#+BEGIN_SRC C :exports both
#include <stdio.h>
#include <stdlib.h>

enum flavor {
    VANILLA = 100,
    CHOCOLATE = 200,
    STRAWBERRY = 300,
};

typedef enum flavor Flavor;

int main() {
    printf("VANILLA=%d\n", VANILLA);
    printf("CHOCOLATE=%d\n", CHOCOLATE);
    printf("STRAWBERRY=%d\n", STRAWBERRY);
    printf("sizeof(Flavor)=%zu\n",
           sizeof(Flavor));
}
#+END_SRC

#+RESULTS:
:RESULTS:
VANILLA=100
CHOCOLATE=200
STRAWBERRY=300
sizeof(Flavor)=4
:END:

*** Enum_loop_trick.c

This is a fun trick to set a maximum value for your enum by using
another symbol


#+BEGIN_SRC C :exports both
#include <stdio.h>
#include <stdlib.h>

// this only works as long as we don't provide our
// own values!

enum flavor {
    VANILLA,
    RHUBARB,
    CHOCOLATE,
    STRAWBERRY,
    N_FLAVORS // Get the free max enum here
};

typedef enum flavor Flavor;

int main() {
    printf("VANILLA=%d\n", VANILLA);
    printf("CHOCOLATE=%d\n", CHOCOLATE);
    printf("STRAWBERRY=%d\n", STRAWBERRY);
    printf("N_FLAVORS=%d\n", N_FLAVORS);
    printf("sizeof(Flavor)=%zu\n",
           sizeof(Flavor));
    
    for (Flavor flavor = 0; flavor < N_FLAVORS; flavor++) {
        switch (flavor) {
            case VANILLA:
                printf("flavor=VANILLA\n");
                break;
            case CHOCOLATE:
                printf("flavor=CHOCOLATE\n");
                break;
            case STRAWBERRY:
                printf("flavor=STRAWBERRY\n");
                break;
            case RHUBARB:
                printf("flavor=RHUBARB\n");
                break;
            default:
                abort();
        }
    }
}
#+END_SRC

#+RESULTS:
:RESULTS:
VANILLA=0
CHOCOLATE=2
STRAWBERRY=3
N_FLAVORS=4
sizeof(Flavor)=4
flavor=VANILLA
flavor=RHUBARB
flavor=CHOCOLATE
flavor=STRAWBERRY
:END:

*** Enum Int

Enum are just integers. And you can treat them as such.

#+BEGIN_SRC C :exports both
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

enum flavor {
    VANILLA,
    CHOCOLATE,
    STRAWBERRY,
    N_FLAVORS // LOOK MA! No Defines! Cute trick, might surprise people.
};

typedef enum flavor Flavor;

// Here we use the fact that enums are really just ints!
Flavor random_flavor() {
    return (rand() % N_FLAVORS);
}

void check_flavor(Flavor flavor) {
    if (flavor >= N_FLAVORS) {
        abort();
    }
    // Since a flavor is just an int, it could be negative...
    if (flavor < 0) {
        abort();
    }
}

const char * get_flavor_name(Flavor flavor) {
    check_flavor(flavor);
    // Here we use "Designated Initializers"!
    const char * const flavor_names[N_FLAVORS] = {
        [CHOCOLATE] = "Hamburger flavor",
        [VANILLA] = "Raspberry",
        [STRAWBERRY] = "Those packets that come in the ramen"
    };
    const char * flavor_name = flavor_names[flavor];
    return flavor_name;
}

int main() {
    srand(time(NULL));
    for (int i = 0 ; i < 4; i++) {
       Flavor flavor = random_flavor();
       printf(
           "flavor %d = %s\n",
           flavor,
           get_flavor_name(flavor)
       );
    }
}
#+END_SRC

#+RESULTS:
:RESULTS:
flavor 1 = Hamburger flavor
flavor 2 = Those packets that come in the ramen
flavor 0 = Raspberry
flavor 1 = Hamburger flavor
:END:

*** Another motivating ENUM Example

#+BEGIN_SRC C :exports both
#include <stdbool.h> 
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

enum card_face {
    ACE = 1,
    FACE2,
    FACE3,
    FACE4,
    FACE5,
    FACE6,
    FACE7,
    FACE8,
    FACE9,
    FACE10,
    JACK,
    QUEEN,
    KING,
};

typedef enum card_face CardFace;

enum card_suit {
    CLUBS,
    HEARTS,
    DIAMONDS,
    SPADES
};

typedef enum card_suit CardSuit;

struct playing_card {
    CardFace face;
    CardSuit suit;
};

typedef struct playing_card PlayingCard;

#define HANDSIZE 5

// A flush is a hand where all cards have the same suit
// like 5 diamonds or 5 hearts
bool isFlush(PlayingCard hand[HANDSIZE]) {
    CardSuit suit = hand[0].suit;
    for (int i = 1;  i < HANDSIZE; i++ ) {
        if (suit != hand[i].suit) {
            return false;
        }
    }
    return true;
}

int main() {
    srand(time(NULL));
    PlayingCard hand[5] = {
        {ACE, CLUBS},
        {FACE2, CLUBS},
        {KING, CLUBS},
        {JACK, CLUBS},
        {FACE4, CLUBS}
    };
    printf("isFlush? %u\n", isFlush(hand));
    PlayingCard secondHand[5] = {
        {ACE, CLUBS},
        {ACE, SPADES},
        {ACE, HEARTS},
        {ACE, DIAMONDS},
        {ACE, CLUBS} // CHEATER
    };
    printf("isFlush? %u\n", isFlush(secondHand));

}
#+END_SRC

#+RESULTS:
:RESULTS:
isFlush? 1
isFlush? 0
:END:



** Unions

- Unions are a way to all the same types to share the same memory.
- Some types like unsigned integers have different sizes:
  
#+BEGIN_SRC C :exports both 
#include <stdio.h>
int main() {
    printf("sizeof(unsigned char):\t\t%ld\n", 
        sizeof(unsigned char));
    printf("sizeof(unsigned short):\t\t%ld\n", 
        sizeof(unsigned short));
    printf("sizeof(unsigned int):\t\t%ld\n", 
        sizeof(unsigned int));
    printf("sizeof(unsigned long):\t\t%ld\n", 
        sizeof(unsigned long));
    printf("sizeof(unsigned long long):\t%ld\n", 
        sizeof(unsigned long long));
    printf("sizeof(unsigned long long int):\t%ld\n", 
        sizeof(unsigned long long int));

}
#+END_SRC

#+RESULTS:
:RESULTS:
sizeof(unsigned char):		1
sizeof(unsigned short):		2
sizeof(unsigned int):		4
sizeof(unsigned long):		8
sizeof(unsigned long long):	8
sizeof(unsigned long long int):	8
:END:

#+BEGIN_SRC C :exports both 
#include <stdio.h>
/*
[C][S][I][I][L][L][L][L]
 S  I  L  L
 I  L
 L
*/
union uints {
    unsigned char a_char;
    unsigned short a_short;
    unsigned int an_int;
    unsigned long a_long;
};
typedef union uints UInts;

#define EXAMPLES 7
int main() {
    unsigned long longs[EXAMPLES] = 
        { 0, 1000, 1000000, 10000000000, 
          65535, 4294967295, 18446744073709551615UL };
    UInts uints;
    for (int i = 0 ; i < EXAMPLES; i++) {
        uints.a_long = longs[i];
        printf("For the long %lu:\n", longs[i]);
        printf("\tchar\t %hhu\n", uints.a_char);
        printf("\tshort\t %hu\n", uints.a_short);
        printf("\tint\t %u\n", uints.an_int);
        printf("\tlong\t %lu\n", uints.a_long);
    }
    // lets see if we can overflow
    uints.a_char++;
    printf("Overflow kept local\t %lu\n", uints.a_long);
}
#+END_SRC

#+RESULTS:
:RESULTS:
For the long 0:
	char	 0
	short	 0
	int	 0
	long	 0
For the long 1000:
	char	 232
	short	 1000
	int	 1000
	long	 1000
For the long 1000000:
	char	 64
	short	 16960
	int	 1000000
	long	 1000000
For the long 10000000000:
	char	 0
	short	 58368
	int	 1410065408
	long	 10000000000
For the long 65535:
	char	 255
	short	 65535
	int	 65535
	long	 65535
For the long 4294967295:
	char	 255
	short	 65535
	int	 4294967295
	long	 4294967295
For the long 18446744073709551615:
	char	 255
	short	 65535
	int	 4294967295
	long	 18446744073709551615
Overflow kept local	 18446744073709551360
:END:

*** Structs versus Unions

#+BEGIN_SRC C
#include <stdio.h>

struct uints {
    unsigned char a_char;
    unsigned short a_short;
    unsigned int an_int;
    unsigned long a_long;
};
typedef struct uints UInts;

int main() {
    UInts uints;
    uints.a_long = 0;
    printf("Hi I'm a struct!\n");
    printf("sizeof(uints)=%zu\n", sizeof(uints));
    printf("sizeof(uints.a_char)=%zu\n", sizeof(uints.a_char));
    printf("sizeof(uints.a_short)=%zu\n", sizeof(uints.a_short));
    printf("sizeof(uints.an_int)=%zu\n", sizeof(uints.an_int));
    printf("sizeof(uints.a_long)=%zu\n", sizeof(uints.a_long));
    printf("&uints=        %p\n", (void *) &uints);
    printf("&uints.a_char= %p\n", (void *) &(uints.a_char));
    printf("&uints.a_short=%p\n", (void *) &(uints.a_short));
    printf("&uints.an_int= %p\n", (void *) &(uints.an_int));
    printf("&uints.a_long= %p\n", (void *) &(uints.a_long));
}
#+END_SRC

#+RESULTS:
:RESULTS:
Hi I'm a struct!
sizeof(uints)=16
sizeof(uints.a_char)=1
sizeof(uints.a_short)=2
sizeof(uints.an_int)=4
sizeof(uints.a_long)=8
&uints=        0x7ffea1ea8590
&uints.a_char= 0x7ffea1ea8590
&uints.a_short=0x7ffea1ea8592
&uints.an_int= 0x7ffea1ea8594
&uints.a_long= 0x7ffea1ea8598
:END:

#+BEGIN_SRC C
#include <stdio.h>

union uints {
    unsigned char a_char;
    unsigned short a_short;
    unsigned int an_int;
    unsigned long a_long;
};
typedef union uints UInts;

int main() {
    UInts uints;
    uints.a_long = 0;
    printf("Hi I'm a Union!\n");
    printf("sizeof(uints)=%zu\n", sizeof(uints));
    printf("sizeof(uints.a_char)=%zu\n", sizeof(uints.a_char));
    printf("sizeof(uints.a_short)=%zu\n", sizeof(uints.a_short));
    printf("sizeof(uints.an_int)=%zu\n", sizeof(uints.an_int));
    printf("sizeof(uints.a_long)=%zu\n", sizeof(uints.a_long));
    printf("&uints=        %p\n", (void *) &uints);
    printf("&uints.a_char= %p\n", (void *) &(uints.a_char));
    printf("&uints.a_short=%p\n", (void *) &(uints.a_short));
    printf("&uints.an_int= %p\n", (void *) &(uints.an_int));
    printf("&uints.a_long= %p\n", (void *) &(uints.a_long));
}
#+END_SRC

#+RESULTS:
:RESULTS:
Hi I'm a Union!
sizeof(uints)=8
sizeof(uints.a_char)=1
sizeof(uints.a_short)=2
sizeof(uints.an_int)=4
sizeof(uints.a_long)=8
&uints=        0x7fff37a95230
&uints.a_char= 0x7fff37a95230
&uints.a_short=0x7fff37a95230
&uints.an_int= 0x7fff37a95230
&uints.a_long= 0x7fff37a95230
:END:


*** Union considerations

    - they are aligned at the starting byte of each member.
    - overflows are kept local to the member being addressed

*** Type Punning      
    - Type punning is breaking the type system to achieve a goal
    - in C it is undefined behaviour to write to 1 part of the union
      and then read from that data using a different overlapping
      member. Yet it pretty common practice.
    - GCC and others typically allow it.

#+BEGIN_SRC C :eval yes :flags -std=c89
#include <stdio.h>
#include <stdint.h>
#include <limits.h>
#include <stdlib.h>

/* This is super useful, but we can't do it in C99 */

struct multi_type {
    enum {
        NOTHING,
        AN_INT,
        A_FLOAT
    } which;
    union {
        int32_t an_int;
        float a_float;
    };
};
typedef struct multi_type MultiType;

void print_mt(MultiType mt) {
    if (mt.which == NOTHING) {
        printf("nothing");
    } else if (mt.which == AN_INT) {
        printf("%d", (int) mt.an_int);
    } else if (mt.which == A_FLOAT) {
        printf("%e", mt.a_float);
    } else {
        abort();
    }
}

void print_mt_array(MultiType *mt_array, size_t length) {
    size_t idx;
    for (idx = 0; idx < length; idx++) {
        print_mt(mt_array[idx]);
        printf(" ");
    }
    printf("\n");
}

MultiType new_mt_int(int value) {
    MultiType new;
    new.which = AN_INT;
    new.an_int = value;
    return new;
}

MultiType new_mt_float(float value) {
    MultiType new;
    new.which = A_FLOAT;
    new.a_float = value;
    return new;
}

int main() {
    MultiType mt_array[4] = { { NOTHING } };
    mt_array[0] = new_mt_int(24);
    mt_array[1] = new_mt_int(48);
    mt_array[2] = new_mt_float(0.24);
    mt_array[3] = new_mt_float(0.12);
    printf("\n");
    print_mt_array(mt_array, 4);
}
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

The error message:

:RESULTS:
/tmp/babel-27627ARt/C-src-27627FnU.c:24:6: error: ISO C99 doesn’t support unnamed structs/unions [-Werror=pedantic]
     };
      ^
cc1: all warnings being treated as errors
/bin/bash: /tmp/babel-27627ARt/C-bin-27627Sxa: Permission denied
:END:


*** Unions with type tags

It is common practice to treat unions like "dynamic types". But it is
common practice to leave a hint in a tag to what type is actually
being stored in that union.

#+BEGIN_SRC C
#include <stdio.h>
#include <stdint.h>
#include <limits.h>
#include <stdlib.h>

// Multitype is either NOTHING, AN_INT, or A_FLOAT
// You should read it and write it based on its type (which)
struct multi_type {
    enum {
        NOTHING,
        AN_INT,
        A_FLOAT
    } which;
    union {
        int32_t an_int;
        float a_float;
    } value;
};
typedef struct multi_type MultiType;

void print_mt(MultiType mt) {
    if (mt.which == NOTHING) {
        printf("nothing");
    } else if (mt.which == AN_INT) {
        printf("%d", (int) mt.value.an_int);
    } else if (mt.which == A_FLOAT) {
        printf("%e", mt.value.a_float);
    } else {
        abort();
    }
}

void print_mt_array(MultiType *mt_array, size_t length) {
    for (size_t idx = 0; idx < length; idx++) {
        print_mt(mt_array[idx]);
        printf(" ");
    }
    printf("\n");
}
#define EXAMPLES 7
int main() {
    MultiType mt_array[EXAMPLES] = {
        { NOTHING },
        { AN_INT, { .an_int=10 } },
        { A_FLOAT, { .a_float=0.1 } },
        { NOTHING },
        { A_FLOAT, { .a_float=99.9 } },
        { AN_INT, { .an_int=99.9 } },
        { AN_INT, { .a_float=-99.9 } },
    };
    printf("\n");
    printf("sizeof(mt_array)    == %lu\n",sizeof(mt_array));
    printf("sizeof(mt_array[0]) == %lu\n",sizeof(mt_array[0]));
    printf("sizeof(mt_array[1]) == %lu\n",sizeof(mt_array[1]));
    printf("sizeof(mt_array[2]) == %lu\n",sizeof(mt_array[2]));
    print_mt_array(mt_array, EXAMPLES);
}
#+END_SRC

#+RESULTS:
:RESULTS:
sizeof(mt_array)    == 56
sizeof(mt_array[0]) == 8
sizeof(mt_array[1]) == 8
sizeof(mt_array[2]) == 8
nothing 10 1.000000e-01 nothing 9.990000e+01 99 -1027093299
:END:

** Malloc! The Heap!

Memory!

Your programs use the following kinds of memory:
- Code: this is for constants and compiled code for the CPU to run
- Data: this is for strings, literals, and other values you predefine
  in your program.
- Stack: this is where the data for your function locals goes
- Heap: this is where dynamically allocated memory goes. It is the largest pool.

What memory does our program use? (OS and compiler specific)
- Globals? Data.
- Static variables? Data.
- Constants? Code and or Data
- Local variables? stack
- Dynamic allocation? heap

*** On my computer

Here's what emacs is using

:EXAMPLE:
root@st-francis:/proc/27627# cat maps
00400000-00641000 r-xp 00000000 09:00 116130283                          /usr/bin/emacs25-x
00841000-00848000 r--p 00241000 09:00 116130283                          /usr/bin/emacs25-x
00848000-01615000 rw-p 00248000 09:00 116130283                          /usr/bin/emacs25-x
03155000-0d208000 rw-p 00000000 00:00 0                                  [heap]
7f16739f4000-7f1673a74000 rw-s 00000000 00:05 935100458                  /SYSV00000000 (deleted)
7f1673a74000-7f1673a79000 r-xp 00000000 09:00 394799                     /usr/lib/x86_64-linux-gnu/gdk-pixbuf-2.0/2.10.0/loaders/libpixbufloader-png.so
7f1673a79000-7f1673c78000 ---p 00005000 09:00 394799                     /usr/lib/x86_64-linux-gnu/gdk-pixbuf-2.0/2.10.0/loaders/libpixbufloader-png.so
7f1673c78000-7f1673c79000 r--p 00004000 09:00 394799                     /usr/lib/x86_64-linux-gnu/gdk-pixbuf-2.0/2.10.0/loaders/libpixbufloader-png.so
...
7f168942a000-7f168942b000 r--p 00027000 09:00 103024636                  /lib/x86_64-linux-gnu/ld-2.27.so
7f168942b000-7f168942c000 rw-p 00028000 09:00 103024636                  /lib/x86_64-linux-gnu/ld-2.27.so
7f168942c000-7f168942d000 rw-p 00000000 00:00 0 
7fffcf9ad000-7fffcfa6d000 rw-p 00000000 00:00 0                          [stack]
7fffcfb29000-7fffcfb2c000 r--p 00000000 00:00 0                          [vvar]
7fffcfb2c000-7fffcfb2e000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
:END:

Here's the important lines
:EXAMPLE:
code        00400000-00641000 r-xp 00000000 09:00 116130283                          /usr/bin/emacs25-x
data?       00841000-00848000 r--p 00241000 09:00 116130283                          /usr/bin/emacs25-x
data?       00848000-01615000 rw-p 00248000 09:00 116130283                          /usr/bin/emacs25-x
heap        03155000-0d208000 rw-p 00000000 00:00 0                                  [heap]
stack       7fffcf9ad000-7fffcfa6d000 rw-p 00000000 00:00 0                          [stack]
:END:

So stack is limited

:EXAMPLE:
hindle1@st-francis:~$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 273535
max locked memory       (kbytes, -l) 16384
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 273535
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
:END:

:RESULTS:
stack size              (kbytes, -s) 8192
:END:

8megs of stack.

What if I want a big array?

I can tell bash to give me more, but sometimes you are limited.

How do programs using more than 8mb of memory?

THE HEAP!!

How do I get heap memory?

malloc!

Can I get it any time.

Sure.

*** Malloc

Just stack allocation
#+BEGIN_SRC C
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void allocAndGo(const int len) {
        int bigArray[len];
        for(int idx=0; idx < len; idx++) {
            bigArray[idx] = idx;
        }
        printf("%u ints allocated!\n",1+bigArray[len-1]);
        printf("%lu bytes!\n", sizeof(int)*len);
}
int main() {
    // let's find the max of the stack.
    for (int i = 1; i < 900000; i+=256*1024) {
        allocAndGo(i);
    }
}
#+END_SRC

#+RESULTS:
:RESULTS:
1 ints allocated!
4 bytes!
262145 ints allocated!
1048580 bytes!
524289 ints allocated!
2097156 bytes!
786433 ints allocated!
3145732 bytes!
:END:


#+BEGIN_SRC C
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int * testAllocArray(int arrLen) {
  size_t size = arrLen * sizeof(int);
  int* array = malloc( size );
  assert(array!=NULL);
  memset((void*)array, 0, size);
  for(int idx=0; idx<arrLen; idx++) {
    array[idx] = idx;
  }
  return array;
}
int main() {
    for (int i = 1; i < 90000000; i+=5*1024*1024) {
        int * bigArray = testAllocArray( i );
        printf("%u ints allocated!\n",1+bigArray[i-1]);
        printf("%lu bytes!\n", sizeof(int)*i);
        free(bigArray); // remember to free it when done!
    }
}
#+END_SRC

#+RESULTS:
:RESULTS:
1 ints allocated!
4 bytes!
5242881 ints allocated!
20971524 bytes!
10485761 ints allocated!
41943044 bytes!
15728641 ints allocated!
62914564 bytes!
20971521 ints allocated!
83886084 bytes!
26214401 ints allocated!
104857604 bytes!
31457281 ints allocated!
125829124 bytes!
36700161 ints allocated!
146800644 bytes!
41943041 ints allocated!
167772164 bytes!
47185921 ints allocated!
188743684 bytes!
52428801 ints allocated!
209715204 bytes!
57671681 ints allocated!
230686724 bytes!
62914561 ints allocated!
251658244 bytes!
68157441 ints allocated!
272629764 bytes!
73400321 ints allocated!
293601284 bytes!
78643201 ints allocated!
314572804 bytes!
83886081 ints allocated!
335544324 bytes!
89128961 ints allocated!
356515844 bytes!
:END:

*** Calloc 

Calloc is like malloc except it will initialize the memory for you!
Just to 0 though. Which is good enough.

Calloc looks different 

calloc( 
man calloc sayss
       void *calloc(size_t nmemb, size_t size);



#+BEGIN_SRC C
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int * testAllocArray(int arrLen) {
  int* array = calloc( sizeof(int), arrLen );
  assert(array!=NULL);
  for(int idx=0; idx<arrLen; idx++) {
    array[idx] = idx;
  }
  return array;
}
int main() {
    for (int i = 1; i < 90000000; i+=5*1024*1024) {
        int * bigArray = testAllocArray( i );
        printf("%u ints allocated!\n",1+bigArray[i-1]);
        printf("%lu bytes!\n", sizeof(int)*i);
        free(bigArray); // remember to free it when done!
    }
}
#+END_SRC

#+RESULTS:
:RESULTS:
1 ints allocated!
4 bytes!
5242881 ints allocated!
20971524 bytes!
10485761 ints allocated!
41943044 bytes!
15728641 ints allocated!
62914564 bytes!
20971521 ints allocated!
83886084 bytes!
26214401 ints allocated!
104857604 bytes!
31457281 ints allocated!
125829124 bytes!
36700161 ints allocated!
146800644 bytes!
41943041 ints allocated!
167772164 bytes!
47185921 ints allocated!
188743684 bytes!
52428801 ints allocated!
209715204 bytes!
57671681 ints allocated!
230686724 bytes!
62914561 ints allocated!
251658244 bytes!
68157441 ints allocated!
272629764 bytes!
73400321 ints allocated!
293601284 bytes!
78643201 ints allocated!
314572804 bytes!
83886081 ints allocated!
335544324 bytes!
89128961 ints allocated!
356515844 bytes!
:END:

*** Malloc2

Big allocation!

#+BEGIN_SRC sh
gcc -std=c99 -Wall -pedantic -Werror -o board ./board.c
./board | wc
#+END_SRC

#+RESULTS:
:    8192    8192 67117056

#+BEGIN_SRC C
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h> // <-- malloc is in stdlib.h

#define KIBI 1024L
#define MEGA (KIBI*KIBI)
#define SIZE 1024*8

/*
 * malloc: Memory ALLOCate, in number of bytes
 * free: deallocate the memory
 *  takes the pointer returned by malloc
 * 
 * Memory still needs to be initialized!
 */

uint8_t * get_board() {
    void * allocated = malloc(sizeof(uint8_t) * SIZE * SIZE);
    if (allocated == NULL) {
        printf("Error: Out of memory!\n");
        abort();
    }
    return allocated;
}

int main() {
    uint8_t (*board)[SIZE] = NULL;
    size_t total_size = sizeof(uint8_t) * SIZE * SIZE;
    board = (uint8_t (*)[SIZE])get_board();
    // board = malloc(total_size);
    for (size_t row = 0; row < SIZE; row++) {
        for (size_t col = 0; col < SIZE; col++) {
            board[row][col] = rand() % 26 + 'A';
        }
    }
    
    for (size_t row = 0; row < SIZE; row++) {
        for (size_t col = 0; col < SIZE; col++) {
            printf("%c", (char) board[row][col]);
        }
        printf("\n");
    }
    printf("board is %zu mebibytes!\n", total_size/MEGA);
    free(board);
    for (size_t row = 0; row < SIZE; row++) {
        for (size_t col = 0; col < SIZE; col++) {
            printf("%c", (char) board[row][col]);
        }
        printf("\n");
    }
}
#+END_SRC

*** strdup

strdup duplicates a string into newly malloc'd memory.

Very handy.

Very dangerous.

#+BEGIN_SRC C
#define _POSIX_C_SOURCE 200809L // <-- needed for strdup
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h> // <-- strdup is in string.h

/*
 * strdup = malloc + strcpy
 */

int main() {
    const char * message = "hello, world!";
    // char buffer[14];
    // strncpy(buffer, message, 14);
    
    // char * copy = malloc((strlen(message) + 1) * sizeof(char));
    // strcpy(copy, message);
    
    char * copy = strdup(message);
    printf("%s\n", copy);
    message[0] = 'H';
    copy[0] = 'H';
    printf("%s\n", copy);
    free(copy);
}
#+END_SRC

*** free

What happens if we don't free?

Our program can get bigger!



#+BEGIN_SRC C
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int * testAllocArray(int arrLen) {
  int* array = calloc( sizeof(int), arrLen );
  assert(array!=NULL);
  for(int idx=0; idx<arrLen; idx++) {
    array[idx] = idx;
  }
  return array;
}
int main() {
    for (int i = 1; i < 10000000; i+=1*1024*1024) {
        int * bigArray = testAllocArray( i );
        printf("%u ints allocated!\n",1+bigArray[i-1]);
        printf("%lu bytes!\n", sizeof(int)*i);
        // free(bigArray); // remember to free it when done!
    }
}
#+END_SRC

#+RESULTS:
:RESULTS:
1 ints allocated!
4 bytes!
1048577 ints allocated!
4194308 bytes!
2097153 ints allocated!
8388612 bytes!
3145729 ints allocated!
12582916 bytes!
4194305 ints allocated!
16777220 bytes!
5242881 ints allocated!
20971524 bytes!
6291457 ints allocated!
25165828 bytes!
7340033 ints allocated!
29360132 bytes!
8388609 ints allocated!
33554436 bytes!
9437185 ints allocated!
37748740 bytes!
:END:

Valgrind is a memory leak detector. It analyzes memory allocations and
warns us about mistakes.

Valgrind will show us that we're leaking memory (losing track of it
and not freeing it).

#+BEGIN_SRC sh
gcc -std=c99 -Wall -pedantic -Werror -o nofree ./nofree.c
valgrind ./nofree 2>&1
valgrind --leak-check=full ./nofree 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
==9746== Memcheck, a memory error detector
==9746== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==9746== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==9746== Command: ./nofree
==9746== 
1 ints allocated!
4 bytes!
1048577 ints allocated!
4194308 bytes!
2097153 ints allocated!
8388612 bytes!
3145729 ints allocated!
12582916 bytes!
4194305 ints allocated!
16777220 bytes!
5242881 ints allocated!
20971524 bytes!
6291457 ints allocated!
25165828 bytes!
7340033 ints allocated!
29360132 bytes!
8388609 ints allocated!
33554436 bytes!
9437185 ints allocated!
37748740 bytes!
==9746== 
==9746== HEAP SUMMARY:
==9746==     in use at exit: 188,743,720 bytes in 10 blocks
==9746==   total heap usage: 11 allocs, 1 frees, 188,747,816 bytes allocated
==9746== 
==9746== LEAK SUMMARY:
==9746==    definitely lost: 117,440,540 bytes in 7 blocks
==9746==    indirectly lost: 0 bytes in 0 blocks
==9746==      possibly lost: 71,303,180 bytes in 3 blocks
==9746==    still reachable: 0 bytes in 0 blocks
==9746==         suppressed: 0 bytes in 0 blocks
==9746== Rerun with --leak-check=full to see details of leaked memory
==9746== 
==9746== For counts of detected and suppressed errors, rerun with: -v
==9746== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==10000== Memcheck, a memory error detector
==10000== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==10000== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==10000== Command: ./nofree
==10000== 
1 ints allocated!
4 bytes!
1048577 ints allocated!
4194308 bytes!
2097153 ints allocated!
8388612 bytes!
3145729 ints allocated!
12582916 bytes!
4194305 ints allocated!
16777220 bytes!
5242881 ints allocated!
20971524 bytes!
6291457 ints allocated!
25165828 bytes!
7340033 ints allocated!
29360132 bytes!
8388609 ints allocated!
33554436 bytes!
9437185 ints allocated!
37748740 bytes!
==10000== 
==10000== HEAP SUMMARY:
==10000==     in use at exit: 188,743,720 bytes in 10 blocks
==10000==   total heap usage: 11 allocs, 1 frees, 188,747,816 bytes allocated
==10000== 
==10000== 71,303,180 bytes in 3 blocks are possibly lost in loss record 1 of 2
==10000==    at 0x4C31B25: calloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==10000==    by 0x1086F6: testAllocArray (in /home/hindle1/projects/CMPUT201/CMPUT201W20B2-public/week07/nofree)
==10000==    by 0x10876F: main (in /home/hindle1/projects/CMPUT201/CMPUT201W20B2-public/week07/nofree)
==10000== 
==10000== 117,440,540 bytes in 7 blocks are definitely lost in loss record 2 of 2
==10000==    at 0x4C31B25: calloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==10000==    by 0x1086F6: testAllocArray (in /home/hindle1/projects/CMPUT201/CMPUT201W20B2-public/week07/nofree)
==10000==    by 0x10876F: main (in /home/hindle1/projects/CMPUT201/CMPUT201W20B2-public/week07/nofree)
==10000== 
==10000== LEAK SUMMARY:
==10000==    definitely lost: 117,440,540 bytes in 7 blocks
==10000==    indirectly lost: 0 bytes in 0 blocks
==10000==      possibly lost: 71,303,180 bytes in 3 blocks
==10000==    still reachable: 0 bytes in 0 blocks
==10000==         suppressed: 0 bytes in 0 blocks
==10000== 
==10000== For counts of detected and suppressed errors, rerun with: -v
==10000== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
#+end_example
