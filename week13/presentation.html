<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-04-07 Tue 11:18 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CMPUT201W20B2 Week 13</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Abram Hindle" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">CMPUT201W20B2 Week 13</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc542ab1">1. Week13</a>
<ul>
<li><a href="#orgab67556">1.1. Copyright Statement</a>
<ul>
<li><a href="#orgc9160e2">1.1.1. License</a></li>
<li><a href="#org15dda61">1.1.2. Hazel Code is licensed under AGPL3.0+</a></li>
</ul>
</li>
<li><a href="#org8c0f47b">1.2. Alternative version</a></li>
<li><a href="#orge550b85">1.3. Init ORG-MODE</a>
<ul>
<li><a href="#orgb3b0541">1.3.1. Org export</a></li>
<li><a href="#orgf0254b5">1.3.2. Org Template</a></li>
</ul>
</li>
<li><a href="#orgb399532">1.4. Remember how to compile?</a></li>
<li><a href="#org67d96b0">1.5. IO</a>
<ul>
<li><a href="#org62e7e49">1.5.1. Streams</a></li>
<li><a href="#org379a538">1.5.2. Files</a></li>
<li><a href="#orga922dd7">1.5.3. Command line arguments</a></li>
<li><a href="#orga24ebce">1.5.4. mmap()</a></li>
</ul>
</li>
<li><a href="#org157e50b">1.6. References</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgc542ab1" class="outline-2">
<h2 id="orgc542ab1"><span class="section-number-2">1</span> Week13</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="https://github.com/abramhindle/CMPUT201W20B2-public/tree/master/week12">https://github.com/abramhindle/CMPUT201W20B2-public/tree/master/week12</a>
</p>
</div>
<div id="outline-container-orgab67556" class="outline-3">
<h3 id="orgab67556"><span class="section-number-3">1.1</span> Copyright Statement</h3>
<div class="outline-text-3" id="text-1-1">
<p>
If you are in CMPUT201 at UAlberta this code is released in the public
domain to you.
</p>

<p>
Otherwise it is (c) 2020 Abram Hindle, Hazel Campbell AGPL3.0+
</p>
</div>

<div id="outline-container-orgc9160e2" class="outline-4">
<h4 id="orgc9160e2"><span class="section-number-4">1.1.1</span> License</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
CMPUT 201 C Notes
Copyright (C) 2020 Abram Hindle, Hazel Campbell
</p>

<p>
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.
</p>

<p>
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.
</p>

<p>
You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.
</p>
</div>
</div>


<div id="outline-container-org15dda61" class="outline-4">
<h4 id="org15dda61"><span class="section-number-4">1.1.2</span> Hazel Code is licensed under AGPL3.0+</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
Hazel's code is also found here
<a href="https://github.com/hazelybell/examples/tree/C-2020-01">https://github.com/hazelybell/examples/tree/C-2020-01</a>
</p>

<p>
Hazel code is licensed: The example code is licensed under the AGPL3+
license, unless otherwise noted.
</p>
</div>
</div>
</div>

<div id="outline-container-org8c0f47b" class="outline-3">
<h3 id="org8c0f47b"><span class="section-number-3">1.2</span> Alternative version</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Checkout the .txt, the .pdf, and the .html version
</p>
</div>
</div>

<div id="outline-container-orge550b85" class="outline-3">
<h3 id="orge550b85"><span class="section-number-3">1.3</span> Init ORG-MODE</h3>
<div class="outline-text-3" id="text-1-3">
<div class="org-src-container">
<pre class="src src-elisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">I need this for org-mode to work well</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">If we have a new org-mode use ob-shell</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">otherwise use ob-sh --- but not both!</span>
(<span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">require</span> '<span style="color: #008b8b;">ob-shell</span> nil 'noerror)
  (<span style="color: #a020f0;">progn</span>
    (org-babel-do-load-languages 'org-babel-load-languages '((shell . t))))
  (<span style="color: #a020f0;">progn</span>
    (<span style="color: #a020f0;">require</span> '<span style="color: #008b8b;">ob-sh</span>)
    (org-babel-do-load-languages 'org-babel-load-languages '((sh . t)))))
(org-babel-do-load-languages 'org-babel-load-languages '((C . t)))
(org-babel-do-load-languages 'org-babel-load-languages '((python . t)))
(<span style="color: #a020f0;">setq</span> org-src-fontify-natively t)
(<span style="color: #a020f0;">setq</span> org-confirm-babel-evaluate nil) <span style="color: #b22222;">;; </span><span style="color: #b22222;">danger!</span>
(custom-set-faces
 '(org-block ((t (<span style="color: #483d8b;">:inherit</span> shadow <span style="color: #483d8b;">:foreground</span> <span style="color: #8b2252;">"black"</span>))))
 '(org-code ((t (<span style="color: #483d8b;">:inherit</span> shadow <span style="color: #483d8b;">:foreground</span> <span style="color: #8b2252;">"black"</span>)))))
</pre>
</div>
</div>

<div id="outline-container-orgb3b0541" class="outline-4">
<h4 id="orgb3b0541"><span class="section-number-4">1.3.1</span> Org export</h4>
<div class="outline-text-4" id="text-1-3-1">
<div class="org-src-container">
<pre class="src src-elisp">(org-html-export-to-html)
(org-latex-export-to-pdf)
(org-ascii-export-to-ascii)
</pre>
</div>
</div>
</div>


<div id="outline-container-orgf0254b5" class="outline-4">
<h4 id="orgf0254b5"><span class="section-number-4">1.3.2</span> Org Template</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Copy and paste this to demo C
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">argc</span>, <span style="color: #228b22;">char</span>**<span style="color: #a0522d;">argv</span>) {
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb399532" class="outline-3">
<h3 id="orgb399532"><span class="section-number-3">1.4</span> Remember how to compile?</h3>
<div class="outline-text-3" id="text-1-4">
<p>
gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o programname programname.c
</p>
</div>
</div>

<div id="outline-container-org67d96b0" class="outline-3">
<h3 id="org67d96b0"><span class="section-number-3">1.5</span> IO</h3>
<div class="outline-text-3" id="text-1-5">
<p>
stdio.h in C contains numerous IO routines.
</p>

<p>
You use it primarily for printf and scanf.
</p>
</div>

<div id="outline-container-org62e7e49" class="outline-4">
<h4 id="org62e7e49"><span class="section-number-4">1.5.1</span> Streams</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
Programs that run in the UNIX terminal have 3 main streams:
</p>

<ul class="org-ul">
<li>stdin 
<ul class="org-ul">
<li>standard in or standard input to read</li>
<li>shell: `&lt;` `|`</li>
<li>C: `gets, getchar, scanf, fgets(stdin,&#x2026;), read(stdin,&#x2026;) , &#x2026;`</li>
</ul></li>
<li>stdout
<ul class="org-ul">
<li>standard out or standard output to write out to the terminals</li>
<li>shell: `&gt;` `|`</li>
<li>C: `puts, printf, fputs(stdout,&#x2026;), fputc(stdout,&#x2026;), &#x2026;`</li>
</ul></li>
<li>stderr: 
<ul class="org-ul">
<li>standard err or standard error to write out to terminals but not
modify the main output</li>
<li>`2&gt;`  or `2&gt;&amp;1 |` or `|&amp;` (bash only)</li>
<li>C: `fputs(stderr,&#x2026;), fputchar(stderr,&#x2026;), fprintf(stderr,&#x2026;), &#x2026;`</li>
</ul></li>
</ul>

<p>
They are called streams because you serially output information to
them. And multiple sources can write to the stream. It's like talking
or a stream of consciousness. 1 byte after another.
</p>
</div>

<ol class="org-ol">
<li><a id="orgbce6704"></a>shell<br />
<div class="outline-text-6" id="text-1-5-1-0-1">
<p>
Typically a terminal will mix stdout and stderr.
</p>

<p>
You can type in input to standard input.
</p>

<p>
You can "pipe" input to standard input: |
</p>

<p>
You can redirect file input to standard input: &lt;
</p>

<p>
Example: using a pipe to pipe the string `ALL CAPS` through the tr
program to lower case it.
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #483d8b;">echo</span> ALL CAPS | tr <span style="color: #8b2252;">'[:upper:]'</span> <span style="color: #8b2252;">'[:lower:]'</span>
</pre>
</div>

<pre class="example">
all caps
</pre>


<p>
tr is a translation program it takes characters from 1 argument and
turns them into another.
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #483d8b;">echo</span> ALL CAPS | tr <span style="color: #8b2252;">'ALC'</span> <span style="color: #8b2252;">'ODP'</span>
</pre>
</div>

<pre class="example">
ODD POPS
</pre>


<p>
We can make files by redirecting stdout to a file
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #483d8b;">echo</span> ALL CAPS &gt; allcaps.txt
cat allcaps.txt | tr <span style="color: #8b2252;">'AL'</span> <span style="color: #8b2252;">'OP'</span>
<span style="color: #483d8b;">echo</span> From Ontario, catch those <span style="color: #b22222;"># </span><span style="color: #b22222;">just echo to stdout</span>
tr <span style="color: #8b2252;">'AC'</span> <span style="color: #8b2252;">'IR'</span> &lt; allcaps.txt
</pre>
</div>

<pre class="example">
OPP COPS
From Ontario, catch those
ILL RIPS
</pre>


<p>
We can filter arbitrary commands:
</p>

<div class="org-src-container">
<pre class="src src-sh">ls | tr <span style="color: #8b2252;">'[:lower:]'</span> <span style="color: #8b2252;">'[:upper:]'</span>
</pre>
</div>

<pre class="example">
20.TXT
30.TXT
ALLCAPS.TXT
ARGV
ARGV.C
ARGV-NEW
ARGVRAND
ARGVRAND.C
AUTO
BINARY.BIN
BINARYREAD.C
BINARYWRITE.C
COOLBEARS.TXT
FFLUSHRANDR
FFLUSHRANDR.C
FFLUSHREADER
FFLUSHREADER.C
FFLUSH.SH
FFLUSH.TXT
FGETS.TXT
FPRINTF.TXT
K_T
MMAPREAD.C
PERROR
PERROR.C
PRESENTATION.HTML
PRESENTATION.HTML~
PRESENTATION.ORG
PRESENTATION.ORG~
PRESENTATION.PDF
PRESENTATION.TEX
PRESENTATION.TEX~
PRESENTATION.TXT
PRESENTATION.TXT~
STDIN-EXAMPLE
STDIN-EXAMPLE.C
STDOUT-EXAMPLE
STDOUT-EXAMPLE.C
</pre>

<p>
We can chain pipes:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #483d8b;">echo</span> translate AC IR LL LK
tr <span style="color: #8b2252;">'AC'</span> <span style="color: #8b2252;">'IR'</span> &lt; allcaps.txt | sed -e <span style="color: #8b2252;">'s/LL/LK/'</span>
<span style="color: #483d8b;">echo</span> translate AC IR LL LK ^S
tr <span style="color: #8b2252;">'AC'</span> <span style="color: #8b2252;">'IR'</span> &lt; allcaps.txt | sed -e <span style="color: #8b2252;">'s/LL/LK/'</span> | <span style="color: #8b2252;">\</span>
   sed -e <span style="color: #8b2252;">'s/^/S/'</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">we can chain commands together</span>
<span style="color: #483d8b;">echo</span> translate AC IR LL LK ^S K K T
tr <span style="color: #8b2252;">'AC'</span> <span style="color: #8b2252;">'IR'</span> &lt; allcaps.txt | sed -e <span style="color: #8b2252;">'s/LL/LK/'</span> | <span style="color: #8b2252;">\</span>
   sed -e <span style="color: #8b2252;">'s/^/S/'</span> | <span style="color: #8b2252;">\</span>
   sed -e <span style="color: #8b2252;">'s/K /K T/'</span>
ls | grep .org | sort
</pre>
</div>

<pre class="example">
translate AC IR LL LK
ILK RIPS
translate AC IR LL LK ^S
SILK RIPS
translate AC IR LL LK ^S K K T
SILK TRIPS
presentation.org
presentation.org~
</pre>


<p>
sed is a useful regular expression program for manipulating text.
</p>
</div>

<ol class="org-ol">
<li><a id="org45285bc"></a>stderr &amp; shell<br />
<div class="outline-text-7" id="text-1-5-1-0-1-1">
<div class="org-src-container">
<pre class="src src-sh">ls -l missing
<span style="color: #a020f0;">exit</span> 0
</pre>
</div>

<p>
Where is it?
</p>

<div class="org-src-container">
<pre class="src src-sh">ls -l missing 2&gt;&amp;1
<span style="color: #a020f0;">exit</span> 0
</pre>
</div>

<pre class="example">
ls: cannot access 'missing': No such file or directory
</pre>


<p>
Once we redirect stderr to stdout we can pipe it and manipulate it!
</p>

<div class="org-src-container">
<pre class="src src-sh">ls -l missing 2&gt;&amp;1 | tr <span style="color: #8b2252;">'[:lower:]'</span> <span style="color: #8b2252;">'[:upper:]'</span>
</pre>
</div>

<pre class="example">
LS: CANNOT ACCESS 'MISSING': NO SUCH FILE OR DIRECTORY
</pre>


<p>
Or perhaps we don't want to see the error
</p>

<div class="org-src-container">
<pre class="src src-sh">ls -l missing 2&gt; /dev/null
<span style="color: #a020f0;">exit</span> 0
</pre>
</div>

<p>
Maybe we just want stderr
</p>
<div class="org-src-container">
<pre class="src src-sh">ls -l *.org missing 2&gt;&amp;1 &gt; /dev/null
<span style="color: #a020f0;">exit</span> 0
</pre>
</div>

<pre class="example">
ls: cannot access 'missing': No such file or directory
</pre>


<p>
Maybe we just want BOTH
</p>
<div class="org-src-container">
<pre class="src src-sh">ls -l *.org missing 2&gt;&amp;1
<span style="color: #a020f0;">exit</span> 0
</pre>
</div>

<pre class="example">
ls: cannot access 'missing': No such file or directory
-rw-r--r-- 1 hindle1 hindle1 27925 Apr  7 11:17 presentation.org
</pre>
</div>
</li>
</ol>
</li>

<li><a id="org8974fe0"></a>C<br />
<ol class="org-ol">
<li><a id="org3dca276"></a>output<br />
<div class="outline-text-7" id="text-1-5-1-0-2-1">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    printf(<span style="color: #8b2252;">"OK this is to stdout!\n"</span>);
    fprintf(stdout,<span style="color: #8b2252;">"OK this is to stdout as well!\n"</span>);
    fprintf(stderr,<span style="color: #8b2252;">"OK this is to stderr!\n"</span>);
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>

<pre class="example">
OK this is to stdout!
OK this is to stdout as well!
</pre>


<p>
Hmmm org-mode ignores stderr
</p>

<div class="org-src-container">
<pre class="src src-shell">gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o stdout-example stdout-example.c
./stdout-example 2&gt;&amp;1
</pre>
</div>

<pre class="example">
OK this is to stderr!
OK this is to stdout!
OK this is to stdout as well!
</pre>


<p>
Ah now it appears
</p>
</div>
</li>


<li><a id="org692af85"></a>input<br />
<div class="outline-text-7" id="text-1-5-1-0-2-2">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">input</span>;
    <span style="color: #a020f0;">if</span> (scanf(<span style="color: #8b2252;">"%d"</span>, &amp;input)!=1) abort();
    fprintf(stdout, <span style="color: #8b2252;">"From stdin %d\n"</span>, input);
    fprintf(stderr, <span style="color: #8b2252;">"ERR: From stdin %d\n"</span>, input);
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell">gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o stdin-example stdin-example.c
<span style="color: #483d8b;">echo</span> 10 | ./stdin-example 2&gt;&amp;1
<span style="color: #483d8b;">echo</span> 20 &gt; 20.txt
<span style="color: #483d8b;">echo</span> 30 &gt; 30.txt
./stdin-example 2&gt;&amp;1 &lt; 20.txt
./stdin-example &lt; 30.txt 2&gt;&amp;1
</pre>
</div>

<pre class="example">
ERR: From stdin 10
From stdin 10
ERR: From stdin 20
From stdin 20
ERR: From stdin 30
From stdin 30
</pre>


<p>
You've mostly seen this before except the `fprintf(stderr,&#x2026;)` part.
</p>
</div>
</li>
</ol>
</li>
</ol>
</div>

<div id="outline-container-org379a538" class="outline-4">
<h4 id="org379a538"><span class="section-number-4">1.5.2</span> Files</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
Files can be addressed as streams as well. But we have to open and
close them. So we can treat files exactly like stdin and stdout but
with a few changes.
</p>

<ol class="org-ol">
<li>We need a file handle (like stdin, stdout, or stderr). This handle
is for the OS to know which file the process is talking about.</li>
<li>We need to decide if we are reading write or both and we need to
open a file to produce a file handle. Or use an existing one.
<ul class="org-ul">
<li>fopen</li>
</ul></li>
<li>We need to write to it using write and f* operations.
<ul class="org-ul">
<li>fprintf</li>
<li>fputs</li>
</ul></li>
<li>We need to read from it using read and f* operations.
<ul class="org-ul">
<li>fgets</li>
<li>fgetc</li>
</ul></li>
<li>We need to close the file after we're done. fclose.</li>
</ol>
</div>

<ol class="org-ol">
<li><a id="orgb6759e7"></a>open and close<br />
<div class="outline-text-5" id="text-1-5-2-1">
<p>
To open a file we use fopen. To close it we fclose. Don't use open and
close because that's not portable. That's for the OS.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #228b22;">FILE</span> *<span style="color: #0000ff;">fopen</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">pathname</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">mode</span>);
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">fclose</span>(<span style="color: #228b22;">FILE</span> *<span style="color: #a0522d;">stream</span>);
</pre>
</div>

<p>
The mode is a string
</p>
<ul class="org-ul">
<li>"r" - read</li>
<li>"w" - write (erase file)</li>
<li>"a" - append (add to end of file)</li>
<li>"r+" - read and write</li>
<li>"w+" - write and read (erase file)</li>
<li>"a+" - append and read</li>
</ul>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">f_cb</span> = fopen(<span style="color: #8b2252;">"coolbears.txt"</span>, <span style="color: #8b2252;">"w"</span>); <span style="color: #b22222;">// </span><span style="color: #b22222;">open coolbears.txt for writing</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">fclose</span>(f_cb); <span style="color: #b22222;">// </span><span style="color: #b22222;">close coolbears.txt</span>
</pre>
</div>

<p>
If you don't close a file you can lose bytes you wrote to it because
they didn't get flushed to disk. This is important because people
might kill your program your you might reboot or shutdown the
computer. If you want to ensure data is written try to engage in
flush. Sometimes no data will appear until you flush or close the
file. Keep those pipes clean.
</p>
</div>

<ol class="org-ol">
<li><a id="org1b36dc4"></a>fopen<br />
<div class="outline-text-6" id="text-1-5-2-1-1">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">SIZE</span> 1024
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">buffer</span>[SIZE] = {<span style="color: #8b2252;">'\0'</span>};
    <span style="color: #b22222;">// </span><span style="color: #b22222;">open coolbears.txt for writing</span>
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">f_cb</span>  = fopen(<span style="color: #8b2252;">"coolbears.txt"</span>, <span style="color: #8b2252;">"w"</span>); 
    <span style="color: #a020f0;">if</span> (f_cb == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open coolbears.txt"</span>);
        abort();
    }
    fputs(<span style="color: #8b2252;">"Polar bears"</span>, f_cb);
    fclose(f_cb);
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">f_cbr</span> = fopen(<span style="color: #8b2252;">"coolbears.txt"</span>, <span style="color: #8b2252;">"r"</span>); 
    <span style="color: #a020f0;">if</span> (f_cbr == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open coolbears.txt"</span>);
        abort();
    }
    fgets(buffer, SIZE, f_cbr);
    printf(<span style="color: #8b2252;">"%s\n"</span>,buffer);
    fclose(f_cbr);
}
</pre>
</div>

<pre class="example">
Polar bears
</pre>
</div>
</li>

<li><a id="org88653a0"></a>perror<br />
<div class="outline-text-6" id="text-1-5-2-1-2">
<p>
perror produces nice errors.
</p>

<p>
perror("An error string"); will report the immediate fopen error if
there is one.
</p>

<p>
Copy this code or put it in macro.
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">file</span> = fopen(<span style="color: #8b2252;">"filename"</span>, <span style="color: #8b2252;">"w"</span>); <span style="color: #b22222;">// </span><span style="color: #b22222;">open coolbears.txt for writing</span>
<span style="color: #a020f0;">if</span> (file == <span style="color: #008b8b;">NULL</span>) {
    perror(<span style="color: #8b2252;">"filename could not be opened"</span>);
    abort();
}
</pre>
</div>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">open a file I can't open</span>
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">f_cb</span>  = fopen(<span style="color: #8b2252;">"/proc/whatever"</span>, <span style="color: #8b2252;">"w"</span>); 
    <span style="color: #a020f0;">if</span> (f_cb == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open /proc/whatever"</span>);
        abort();
    }
    printf(<span style="color: #8b2252;">"We shouldn't be here!\n"</span>);
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o perror ./perror.c &amp;&amp; <span style="color: #8b2252;">\</span>
./perror 2&gt;&amp;1 
<span style="color: #a020f0;">exit</span> 0
</pre>
</div>

<pre class="example">
Couldn't open /proc/whatever: No such file or directory
Aborted (core dumped)
</pre>
</div>
</li>

<li><a id="orgf9c5a95"></a>closing<br />
<div class="outline-text-6" id="text-1-5-2-1-3">
<p>
OK but what if we don't close it?
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">SIZE</span> 1024
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">buffer</span>[SIZE] = {<span style="color: #8b2252;">'\0'</span>};
    <span style="color: #b22222;">// </span><span style="color: #b22222;">open coolbears.txt for writing</span>
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">f_cb</span>  = fopen(<span style="color: #8b2252;">"coolbears.txt"</span>, <span style="color: #8b2252;">"w"</span>); 
    <span style="color: #a020f0;">if</span> (f_cb == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open coolbears.txt"</span>);
        abort();
    }
    fputs(<span style="color: #8b2252;">"Polar bears"</span>, f_cb);
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">f_cbr</span> = fopen(<span style="color: #8b2252;">"coolbears.txt"</span>, <span style="color: #8b2252;">"r"</span>); 
    <span style="color: #a020f0;">if</span> (f_cbr == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open coolbears.txt"</span>);
        abort();
    }
    fgets(buffer, SIZE, f_cbr);
    printf(<span style="color: #8b2252;">"This is the buffer before close: %s\n"</span>,buffer);
    fclose(f_cbr);
    fclose(f_cb);
    f_cbr = fopen(<span style="color: #8b2252;">"coolbears.txt"</span>, <span style="color: #8b2252;">"r"</span>); 
    <span style="color: #a020f0;">if</span> (f_cbr == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open coolbears.txt"</span>);
        abort();
    }
    fgets(buffer, SIZE, f_cbr);
    printf(<span style="color: #8b2252;">"This is the buffer after close: %s\n"</span>,buffer);
    fclose(f_cbr);
    printf(<span style="color: #8b2252;">"Close your buffers!"</span>);
}
</pre>
</div>

<pre class="example">
This is the buffer before close: 
This is the buffer after close: Polar bears
Close your buffers!
</pre>


<div class="org-src-container">
<pre class="src src-sh">cat coolbears.txt
</pre>
</div>

<pre class="example">
Polar bears
</pre>
</div>

<ol class="org-ol">
<li><a id="org9825ec2"></a>fflushing and fclose<br />
<div class="outline-text-7" id="text-1-5-2-1-3-1">
<p>
Now let's see what flush does for us!
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">SIZE</span> 1024
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">buffer</span>[SIZE] = {<span style="color: #8b2252;">'\0'</span>};
    <span style="color: #b22222;">// </span><span style="color: #b22222;">open coolbears.txt for writing</span>
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">f_cb</span>  = fopen(<span style="color: #8b2252;">"coolbears.txt"</span>, <span style="color: #8b2252;">"w"</span>); 
    <span style="color: #a020f0;">if</span> (f_cb == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open coolbears.txt"</span>);
        abort();
    }
    fputs(<span style="color: #8b2252;">"Polar bears"</span>, f_cb);
    fflush(f_cb); <span style="color: #b22222;">// </span><span style="color: #b22222;">WE'RE FLUSHING!</span>
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">f_cbr</span> = fopen(<span style="color: #8b2252;">"coolbears.txt"</span>, <span style="color: #8b2252;">"r"</span>); 
    <span style="color: #a020f0;">if</span> (f_cbr == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open coolbears.txt"</span>);
        abort();
    }
    fgets(buffer, SIZE, f_cbr);
    printf(<span style="color: #8b2252;">"This is the buffer before close but after flush: %s\n"</span>,buffer);
    fclose(f_cbr);
    fclose(f_cb);
    f_cbr = fopen(<span style="color: #8b2252;">"coolbears.txt"</span>, <span style="color: #8b2252;">"r"</span>); 
    <span style="color: #a020f0;">if</span> (f_cbr == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open coolbears.txt"</span>);
        abort();
    }
    fgets(buffer, SIZE, f_cbr);
    printf(<span style="color: #8b2252;">"This is the buffer after close: %s\n"</span>,buffer);
    fclose(f_cbr);
    printf(<span style="color: #8b2252;">"Close your buffers! Keep your pipes clean"</span>);
}
</pre>
</div>

<pre class="example">
This is the buffer before close but after flush: Polar bears
This is the buffer after close: Polar bears
Close your buffers! Keep your pipes clean
</pre>
</div>
</li>
</ol>
</li>
</ol>
</li>

<li><a id="orgd00412a"></a>writing<br />
<ol class="org-ol">
<li><a id="org8342bc8"></a>fprintf<br />
<div class="outline-text-6" id="text-1-5-2-2-1">
<p>
fprintf is printf for files. It takes a FILE * as the first argument
and then it looks like printf after that.
</p>

<p>
fputs is available too and does the same thing except no laying out of
strings.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">SIZE</span> 1024
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">buffer</span>[SIZE] = {<span style="color: #8b2252;">'\0'</span>};
    <span style="color: #b22222;">// </span><span style="color: #b22222;">open coolbears.txt for writing</span>
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">f_cb</span>  = fopen(<span style="color: #8b2252;">"fprintf.txt"</span>, <span style="color: #8b2252;">"w"</span>); 
    <span style="color: #a020f0;">if</span> (f_cb == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open fprintf.txt"</span>);
        abort();
    }
    <span style="color: #b22222;">// </span><span style="color: #b22222;">It's just like printf!</span>
    fprintf(f_cb,<span style="color: #8b2252;">"A random number %d\n"</span>, rand());
    fclose(f_cb);
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">f_cbr</span> = fopen(<span style="color: #8b2252;">"fprintf.txt"</span>, <span style="color: #8b2252;">"r"</span>); 
    <span style="color: #a020f0;">if</span> (f_cbr == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open fprintf.txt"</span>);
        abort();
    }
    fgets(buffer, SIZE, f_cbr);
    printf(<span style="color: #8b2252;">"%s\n"</span>,buffer);
    fclose(f_cbr);
}
</pre>
</div>

<pre class="example">
A random number 112264849
</pre>
</div>
</li>
</ol>
</li>

<li><a id="orgba3841a"></a>reading<br />
<div class="outline-text-5" id="text-1-5-2-3">
<p>
For reading text from a file you options like fgets, fgetc, and
fscanf.
</p>
</div>

<ol class="org-ol">
<li><a id="orgd09c45c"></a>fscanf<br />
<div class="outline-text-6" id="text-1-5-2-3-1">
<p>
fscanf looks and feels like scanf except it outputs to FILE * streams.
The first argument is a FILE *.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">SIZE</span> 1024
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">CHECK</span>(<span style="color: #a0522d;">x</span>) ((x)==1)?1:(abort(),0);
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">buffer</span>[SIZE] = {<span style="color: #8b2252;">'\0'</span>};
    <span style="color: #b22222;">// </span><span style="color: #b22222;">open coolbears.txt for writing</span>
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">f_cb</span>  = fopen(<span style="color: #8b2252;">"fprintf.txt"</span>, <span style="color: #8b2252;">"w"</span>); 
    <span style="color: #a020f0;">if</span> (f_cb == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open fprintf.txt"</span>);
        abort();
    }
    <span style="color: #b22222;">// </span><span style="color: #b22222;">It's just like printf!</span>
    fprintf(f_cb,<span style="color: #8b2252;">"A random number %d\n"</span>, rand());
    fclose(f_cb);
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">f_cbr</span> = fopen(<span style="color: #8b2252;">"fprintf.txt"</span>, <span style="color: #8b2252;">"r"</span>); 
    <span style="color: #a020f0;">if</span> (f_cbr == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open fprintf.txt"</span>);
        abort();
    }

    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0 ; i &lt; 3; i++) {
        CHECK(fscanf(f_cbr, <span style="color: #8b2252;">"%s"</span>,buffer));
        printf(<span style="color: #8b2252;">"%s\n"</span>,buffer);
    }
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">input</span>=0;
    CHECK(fscanf(f_cbr, <span style="color: #8b2252;">"%d"</span>,&amp;input));
    printf(<span style="color: #8b2252;">"%d\n"</span>, input);
    fclose(f_cbr);
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>

<pre class="example">
A
random
number
112264849
</pre>
</div>
</li>

<li><a id="orge5a7df5"></a>fgets<br />
<div class="outline-text-6" id="text-1-5-2-3-2">
<p>
fgets gets a little complicated because you have to test for EOF. You
can check for an null response and use the feof function, but probably
you have to do both. If you find you're repeating the last line of a
file it is because you are reading nothing and you're reusing the
buffer you just used.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;time.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">SIZE</span> 1024
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">N</span> 8
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">buffer</span>[SIZE] = {<span style="color: #8b2252;">'\0'</span>};
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #b22222;">// </span><span style="color: #b22222;">open coolbears.txt for writing</span>
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">filew</span>  = fopen(<span style="color: #8b2252;">"fgets.txt"</span>, <span style="color: #8b2252;">"w"</span>); 
    <span style="color: #a020f0;">if</span> (filew == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open fgets.txt"</span>);
        abort();
    }

    <span style="color: #b22222;">// </span><span style="color: #b22222;">It's just like printf!</span>
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">totalLines</span> = 1 + (rand() % N);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0 ; i &lt; totalLines; i++) {
        fprintf(filew,<span style="color: #8b2252;">"A random number %d\n"</span>, rand());
    }
    fclose(filew);
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">filer</span> = fopen(<span style="color: #8b2252;">"fgets.txt"</span>, <span style="color: #8b2252;">"r"</span>); 
    <span style="color: #a020f0;">if</span> (filer == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open fgets.txt"</span>);
        abort();
    }

    <span style="color: #a020f0;">while</span>(!feof(filer)) {
        <span style="color: #a020f0;">if</span> (fgets(buffer, SIZE, filer)) {
           printf(<span style="color: #8b2252;">"fgets.txt: %s"</span>, buffer);
        }
    }
    fclose(filer);
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>

<pre class="example">
fgets.txt: A random number 911643185
fgets.txt: A random number 2133168822
</pre>
</div>
</li>
</ol>
</li>

<li><a id="orgcaebe42"></a>flushing<br />
<div class="outline-text-5" id="text-1-5-2-4">
<p>
If you want to ensure something gets to a file or a term you should
flush. Typically I/O is BUFFERED. Buffered means it is flushed once a
certain threshold is met, typically size but sometimes time (depending
on the system). Buffered will increase latency to print something but
will often improve overall bandwidth to disk.
</p>

<div class="org-src-container">
<pre class="src src-C">fflush(<span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">stream</span>); <span style="color: #b22222;">// </span><span style="color: #b22222;">will flush your stream</span>
</pre>
</div>

<p>
Flush when you need to.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;time.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;unistd.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">SIZE</span> 5
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">file</span> = fopen(<span style="color: #8b2252;">"fflush.txt"</span>, <span style="color: #8b2252;">"w"</span>); 
    <span style="color: #a020f0;">if</span> (file == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open fflush.txt"</span>);
        abort();
    }
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0 ; i &lt; SIZE; i++) {
        fprintf(file, <span style="color: #8b2252;">"%d\n"</span>, rand());
        fflush(file); <span style="color: #b22222;">// </span><span style="color: #b22222;">WE'RE FLUSHING!</span>
        sleep(1);
    }
    fclose(file);
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;time.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;unistd.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">SIZE</span> 20
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">BUFF</span> 1024
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">buffer</span>[BUFF];
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">file</span> = fopen(<span style="color: #8b2252;">"fflush.txt"</span>, <span style="color: #8b2252;">"r"</span>); 
    <span style="color: #a020f0;">if</span> (file == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open fflush.txt"</span>);
        abort();
    }
    <span style="color: #a020f0;">while</span>(!feof(file)) {
        <span style="color: #a020f0;">if</span> (!fgets(buffer,BUFF,file)) {
            <span style="color: #a020f0;">break</span>;
        }
        printf(<span style="color: #8b2252;">"%s"</span>, buffer);
        sleep(1);
    }
    fclose(file);
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o fflushrandr fflushrandr.c &amp;&amp; <span style="color: #8b2252;">\</span>
gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o fflushreader fflushreader.c &amp;&amp; <span style="color: #8b2252;">\</span>
<span style="color: #483d8b;">echo</span> This will take 7 seconds &amp;&amp; <span style="color: #8b2252;">\</span>
( ./fflushrandr &amp; sleep 2; ./fflushreader)
</pre>
</div>

<pre class="example">
This will take 7 seconds
112264849
911643185
2133168822
311463743
107686933
</pre>
</div>
</li>
<li><a id="org6d2be31"></a>Binary Files<br />
<div class="outline-text-5" id="text-1-5-2-5">
<p>
From stdio.h:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #228b22;">size_t</span> <span style="color: #0000ff;">fread</span>(<span style="color: #228b22;">void</span> *<span style="color: #a0522d;">ptr</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">nmemb</span>, <span style="color: #228b22;">FILE</span> *<span style="color: #a0522d;">stream</span>);

<span style="color: #228b22;">size_t</span> <span style="color: #0000ff;">fwrite</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">void</span> *<span style="color: #a0522d;">ptr</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">nmemb</span>,
              <span style="color: #228b22;">FILE</span> *<span style="color: #a0522d;">stream</span>);
</pre>
</div>

<p>
fread and fwrite will write memory to a stream and back again. Any
pointer can be used, the bytes in memory will be serialized in and
out. It will not be compiler and architecture portable so carefully
craft your structs before you write them out. Use explicit padding.
For 64-bit and 32-bit compatibility pad to modulus 8 bytes.
</p>
</div>

<ol class="org-ol">
<li><a id="org011797c"></a>Writing Binary Files<br />
<div class="outline-text-6" id="text-1-5-2-5-1">
<p>
fwrite is our buddy. It will help us write arbitrary sections of
memory to a file.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;assert.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;time.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">SIZE</span> 5
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">demo</span> {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>;
    <span style="color: #228b22;">float</span> <span style="color: #a0522d;">f</span>;
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">d</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span>;
};
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">file</span> = fopen(<span style="color: #8b2252;">"binary.bin"</span>, <span style="color: #8b2252;">"w"</span>); 
    <span style="color: #a020f0;">if</span> (file == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open binary.bin"</span>);
        abort();
    }

    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">realSize</span> = 1 + (rand() % SIZE);
    assert(1==fwrite(&amp;realSize, <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>), 1, file));
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0 ; i &lt; realSize; i++) {
        <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">demo</span> <span style="color: #a0522d;">randd</span>;
        randd.i = rand();
        randd.f = rand() / 2.0F;
        randd.d = 1.0 / (rand()+1.0);
        randd.c = <span style="color: #8b2252;">'X'</span>;
        printf(<span style="color: #8b2252;">"Writing %d\n"</span>, randd.i);
        printf(<span style="color: #8b2252;">"\tWriting %g\n"</span>, randd.f);
        printf(<span style="color: #8b2252;">"\tWriting %g\n"</span>, randd.d);
        printf(<span style="color: #8b2252;">"\tWriting %c\n"</span>, randd.c);
        assert(1==fwrite(&amp;randd, <span style="color: #a020f0;">sizeof</span>(randd), 1, file));
    }
    fclose(file);
}
</pre>
</div>

<pre class="example">
Writing 1556810690
	Writing 4.40577e+08
	Writing 2.33677e-09
	Writing X
Writing 1110686519
	Writing 1.83227e+08
	Writing 7.28036e-09
	Writing X
Writing 751235823
	Writing 2.76687e+08
	Writing 7.81354e-10
	Writing X
Writing 326008578
	Writing 1.90675e+08
	Writing 1.3878e-09
	Writing X
Writing 683567098
	Writing 3.33857e+08
	Writing 2.2767e-09
	Writing X
</pre>

<p>
So those structs are written to binary.bin
</p>

<p>
When you write out structs, watch for padding. Look for the letter X.
Count the number of bytes after the last X.
</p>

<div class="org-src-container">
<pre class="src src-sh">hexdump -C binary.bin
</pre>
</div>

<pre class="example">
00000000  05 00 00 00 c2 0b cb 5c  5a 15 d2 4d 78 b0 24 ec  |.......\Z..Mx.$.|
00000010  9a 12 24 3e 58 4c 6e e0  8c 55 00 00 37 bb 33 42  |..$&gt;XLn..U..7.3B|
00000020  0f bd 2e 4d 76 15 ef 47  d8 44 3f 3e 58 4c 6e e0  |...Mv..G.D?&gt;XLn.|
00000030  8c 55 00 00 ef f2 c6 2c  47 ef 83 4d 6b 5f 3f 3a  |.U.....,G..Mk_?:|
00000040  dd d8 0a 3e 58 4c 6e e0  8c 55 00 00 02 7f 6e 13  |...&gt;XLn..U....n.|
00000050  66 d7 35 4d 4b a2 bb 63  9b d7 17 3e 58 4c 6e e0  |f.5MK..c...&gt;XLn.|
00000060  8c 55 00 00 fa 67 be 28  16 32 9f 4d 9b 0d e6 3a  |.U...g.(.2.M...:|
00000070  85 8e 23 3e 58 4c 6e e0  8c 55 00 00              |..#&gt;XLn..U..|
0000007c
</pre>
</div>
</li>

<li><a id="org3fede59"></a>Reading binary<br />
<div class="outline-text-6" id="text-1-5-2-5-2">
<p>
Reading binary requires that you know what types you are reading. Be
warned that if you mix different types you need to read them in proper
order.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;assert.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;time.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">BUFF</span> 1024
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">demo</span> {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>;
    <span style="color: #228b22;">float</span> <span style="color: #a0522d;">f</span>;
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">d</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span>;
};
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">buffer</span>[BUFF];
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">file</span> = fopen(<span style="color: #8b2252;">"binary.bin"</span>, <span style="color: #8b2252;">"r"</span>); 
    <span style="color: #a020f0;">if</span> (file == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open binary.bin"</span>);
        abort();
    }
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">size</span>=0;
    assert(1==fread(&amp;size, <span style="color: #a020f0;">sizeof</span>(size), 1, file));
    <span style="color: #b22222;">// </span><span style="color: #b22222;">we'll just ignore the size and just keep reading until we have</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">to stop.</span>
    <span style="color: #a020f0;">while</span>(!feof(file)) {
        <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">demo</span> <span style="color: #a0522d;">readDemo</span>;
        <span style="color: #a020f0;">if</span> (1!=fread(&amp;readDemo, <span style="color: #a020f0;">sizeof</span>(readDemo), 1, file)) {
           <span style="color: #a020f0;">break</span>;
        }
        printf(<span style="color: #8b2252;">"Reading %d\n"</span>, readDemo.i);
        printf(<span style="color: #8b2252;">"\tReading %f\n"</span>, readDemo.f);
        printf(<span style="color: #8b2252;">"\tReading %g\n"</span>, readDemo.d);
        printf(<span style="color: #8b2252;">"\tReading %c\n"</span>, readDemo.c);
    }
    fclose(file);
}
</pre>
</div>

<pre class="example">
Reading 1556810690
	Reading 440576832.000000
	Reading 2.33677e-09
	Reading X
Reading 1110686519
	Reading 183226608.000000
	Reading 7.28036e-09
	Reading X
Reading 751235823
	Reading 276687072.000000
	Reading 7.81354e-10
	Reading X
Reading 326008578
	Reading 190674528.000000
	Reading 1.3878e-09
	Reading X
Reading 683567098
	Reading 333857472.000000
	Reading 2.2767e-09
	Reading X
</pre>
</div>
</li>
</ol>
</li>
</ol>
</div>

<div id="outline-container-orga922dd7" class="outline-4">
<h4 id="orga922dd7"><span class="section-number-4">1.5.3</span> Command line arguments</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
How do I make program like?
</p>

<div class="org-src-container">
<pre class="src src-sh">./argv some commandline args -l
</pre>
</div>

<p>
To get arguments from the commandline you can add the parameters:
</p>
<ul class="org-ul">
<li>`int argc` &#x2013; number of commandline arguments</li>
<li>`char ** argv` &#x2013; array of strings of commandline arguments</li>
</ul>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">argc</span>, <span style="color: #228b22;">char</span> ** <span style="color: #a0522d;">argv</span>) {
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0 ; i &lt; argc; i++) {
        printf(<span style="color: #8b2252;">"arg %d: %s\t"</span>, i, argv[i]);
    }
    puts(<span style="color: #8b2252;">""</span>);
}
</pre>
</div>

<pre class="example">
arg 0: /tmp/babel-7888jxN/C-bin-7888vnt
</pre>


<div class="org-src-container">
<pre class="src src-sh">gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o argv argv.c &amp;&amp; <span style="color: #8b2252;">\</span>
./argv &amp;&amp;  <span style="color: #8b2252;">\</span>
./argv 1  &amp;&amp; <span style="color: #8b2252;">\</span>
./argv 1 2 &amp;&amp; <span style="color: #8b2252;">\</span>
./argv 1 2 3 &amp;&amp; <span style="color: #8b2252;">\</span>
cp -f argv argv-new &amp;&amp; <span style="color: #8b2252;">\</span>
./argv-new 1 2 3 
</pre>
</div>

<pre class="example">
arg 0: ./argv	
arg 0: ./argv	arg 1: 1	
arg 0: ./argv	arg 1: 1	arg 2: 2	
arg 0: ./argv	arg 1: 1	arg 2: 2	arg 3: 3	
arg 0: ./argv-new	arg 1: 1	arg 2: 2	arg 3: 3	
</pre>
</div>


<ol class="org-ol">
<li><a id="org0138d31"></a>atoi for integer arguments<br />
<div class="outline-text-5" id="text-1-5-3-1">
<p>
So atoi is your friend :)
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">argc</span>, <span style="color: #228b22;">char</span> ** <span style="color: #a0522d;">argv</span>) {
    <span style="color: #a020f0;">if</span> (argc != 2) { exit(1); }
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">n</span> = atoi(argv[1]);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0 ; i &lt; n; i++) {
        printf(<span style="color: #8b2252;">"%d\t"</span>, rand());
    }
    printf(<span style="color: #8b2252;">"\n"</span>);
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 <span style="color: #8b2252;">\</span>
     -o argvrand argvrand.c &amp;&amp; <span style="color: #8b2252;">\</span>
(./argvrand || <span style="color: #483d8b;">echo</span> not enough args: $<span style="color: #a0522d;">?</span>) &amp;&amp; <span style="color: #8b2252;">\</span>
./argvrand 1 &amp;&amp; <span style="color: #8b2252;">\</span>
./argvrand 2 &amp;&amp; <span style="color: #8b2252;">\</span>
./argvrand 3 &amp;&amp; <span style="color: #8b2252;">\</span>
./argvrand 0 
</pre>
</div>

<pre class="example">
not enough args: 1
1804289383	
1804289383	846930886	
1804289383	846930886	1681692777	

</pre>
</div>
</li>
</ol>
</div>


<div id="outline-container-orga24ebce" class="outline-4">
<h4 id="orga24ebce"><span class="section-number-4">1.5.4</span> mmap()</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
mmap is neat, it maps memory to and from a file or even another
process. We do this with shared libraries too. So you can read and
write to a file just by writing to memory. The OS deals with it very
effeciently you just have to be very size aware. mmapping files is not
good for streams and stream processing, it gets complicated. It is
good for fixed sized structs.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;assert.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;sys/mman.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;sys/types.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;time.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">SIZE</span> 2
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">demo</span> {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>;
    <span style="color: #228b22;">float</span> <span style="color: #a0522d;">f</span>;
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">d</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span>;
    <span style="color: #b22222;">// </span><span style="color: #b22222;">char cc[7]; // you can make padding explicit</span>
};
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">file</span> = fopen(<span style="color: #8b2252;">"binary.bin"</span>, <span style="color: #8b2252;">"r+"</span>); 
    <span style="color: #a020f0;">if</span> (file == <span style="color: #008b8b;">NULL</span>) {
        perror(<span style="color: #8b2252;">"Couldn't open binary.bin"</span>);
        abort();
    }
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">fd</span> = fileno(file);
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">rsize</span> = 0;
    assert(1==fread(&amp;rsize, <span style="color: #a020f0;">sizeof</span>(rsize), 1, file));
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span> = <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>) + <span style="color: #a020f0;">sizeof</span>(<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">demo</span>) * rsize;
    printf(<span style="color: #8b2252;">"N %d struct demos are in binary.bin\n"</span>, rsize);
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">new_size</span> = size + <span style="color: #a020f0;">sizeof</span>(<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">demo</span>);
    <span style="color: #b22222;">// </span><span style="color: #b22222;">if you want to increase a file's size use ftruncate </span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">before you do this</span>
    ftruncate(fd, new_size); 
    printf(<span style="color: #8b2252;">"mmapping %u bytes of memory from the file\n"</span>, new_size);
    <span style="color: #228b22;">int</span> * <span style="color: #a0522d;">mapped</span> = mmap(0, 
        new_size,
        PROT_READ | PROT_WRITE, 
        MAP_SHARED, 
        fd, 
        0);
    <span style="color: #a020f0;">if</span> (mapped == MAP_FAILED) {
        perror(<span style="color: #8b2252;">"mmap"</span>);
        exit(1);
    }
    <span style="color: #b22222;">// </span><span style="color: #b22222;">read 4 bytes from the head</span>
    assert(rsize == (<span style="color: #228b22;">int</span>)*mapped);
    <span style="color: #b22222;">// </span><span style="color: #b22222;">really abusive but we're 1 int after the start eh</span>
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">demo</span> * <span style="color: #a0522d;">demos</span> = (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">demo</span> *)(mapped+1);
    <span style="color: #b22222;">// </span><span style="color: #b22222;">OK now look for the read ?</span>
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0 ; i &lt; rsize; i++) {
        <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">demo</span> <span style="color: #a0522d;">randd</span> = demos[i];
        printf(<span style="color: #8b2252;">"Reading %d\n"</span>, randd.i);
        printf(<span style="color: #8b2252;">"\tReading %g\n"</span>, randd.f);
        printf(<span style="color: #8b2252;">"\tReading %g\n"</span>, randd.d);
        printf(<span style="color: #8b2252;">"\tReading %c\n"</span>, randd.c);
    }
    <span style="color: #b22222;">// </span><span style="color: #b22222;">demo we can write a -1</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">run the program twice and your first integer is -1</span>
    demos[0].i = -1;
    <span style="color: #b22222;">// </span><span style="color: #b22222;">now let's extend the file by 1 record!</span>
    demos[rsize] = demos[rsize-1];
    mapped[0] = rsize+1;
    munmap(demos, size);
    fclose(file);
}
</pre>
</div>

<pre class="example">
N 5 struct demos are in binary.bin
mmapping 148 bytes of memory from the file
Reading 1556810690
	Reading 4.40577e+08
	Reading 2.33677e-09
	Reading X
Reading 1110686519
	Reading 1.83227e+08
	Reading 7.28036e-09
	Reading X
Reading 751235823
	Reading 2.76687e+08
	Reading 7.81354e-10
	Reading X
Reading 326008578
	Reading 1.90675e+08
	Reading 1.3878e-09
	Reading X
Reading 683567098
	Reading 3.33857e+08
	Reading 2.2767e-09
	Reading X
</pre>

<div class="org-src-container">
<pre class="src src-sh">ls -l binary.bin
</pre>
</div>

<pre class="example">
-rw-rw-r-- 1 hindle1 hindle1 148 Apr  7 11:18 binary.bin
</pre>


<p>
If you want to see some bad code that's small and uses mmap checkout:
</p>

<p>
<a href="https://github.com/abramhindle/a-simple-pseudo-bayesian-spam-filter/blob/master/filter.c">https://github.com/abramhindle/a-simple-pseudo-bayesian-spam-filter/blob/master/filter.c</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org157e50b" class="outline-3">
<h3 id="org157e50b"><span class="section-number-3">1.6</span> References</h3>
<div class="outline-text-3" id="text-1-6">
<p>
KN King, C Programming, Chapter 28, 2nd Edition
</p>

<p>
Hazel Cambell's thorough notes on Stream I/O:
<a href="https://docs.google.com/document/d/1b48EzfP03JYEFt42wCajU5kv76oVbTxEXa2JO0q17ag/edit">https://docs.google.com/document/d/1b48EzfP03JYEFt42wCajU5kv76oVbTxEXa2JO0q17ag/edit</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Abram Hindle</p>
<p class="date">Created: 2020-04-07 Tue 11:18</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
